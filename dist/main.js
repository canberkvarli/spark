/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/audiomotion-analyzer/src/audioMotion-analyzer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/audiomotion-analyzer/src/audioMotion-analyzer.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ AudioMotionAnalyzer; }\n/* harmony export */ });\n/**!\n * audioMotion-analyzer\n * High-resolution real-time graphic audio spectrum analyzer JS module\n *\n * @version 3.6.1\n * @author  Henrique Avila Vianna <hvianna@gmail.com> <https://henriquevianna.com>\n * @license AGPL-3.0-or-later\n */\n\nconst VERSION = '3.6.1';\n\n// internal constants\nconst TAU     = 2 * Math.PI,\n\t  HALF_PI = Math.PI / 2,\n\t  RPM     = TAU / 3600,           // angle increment per frame for one revolution per minute @60fps\n\t  ROOT24  = 2 ** ( 1 / 24 ),      // 24th root of 2\n\t  C0      = 440 * ROOT24 ** -114; // ~16.35 Hz\n\nclass AudioMotionAnalyzer {\n\n/**\n * CONSTRUCTOR\n *\n * @param {object} [container] DOM element where to insert the analyzer; if undefined, uses the document body\n * @param {object} [options]\n * @returns {object} AudioMotionAnalyzer object\n */\n\tconstructor( container, options = {} ) {\n\n\t\tthis._ready = false;\n\n\t\t// Gradient definitions\n\n\t\tthis._gradients = {\n\t\t\tclassic: {\n\t\t\t\tbgColor: '#111',\n\t\t\t\tcolorStops: [\n\t\t\t\t\t'hsl( 0, 100%, 50% )',\n\t\t\t\t\t{ pos: .6, color: 'hsl( 60, 100%, 50% )' },\n\t\t\t\t\t'hsl( 120, 100%, 50% )'\n\t\t\t\t]\n\t\t\t},\n\t\t\tprism:   {\n\t\t\t\tbgColor: '#111',\n\t\t\t\tcolorStops: [\n\t\t\t\t\t'hsl( 0, 100%, 50% )',\n\t\t\t\t\t'hsl( 60, 100%, 50% )',\n\t\t\t\t\t'hsl( 120, 100%, 50% )',\n\t\t\t\t\t'hsl( 180, 100%, 50% )',\n\t\t\t\t\t'hsl( 240, 100%, 50% )'\n\t\t\t\t]\n\t\t\t},\n\t\t\trainbow: {\n\t\t\t\tbgColor: '#111',\n\t\t\t\tdir: 'h',\n\t\t\t\tcolorStops: [\n\t\t\t\t\t'hsl( 0, 100%, 50% )',\n\t\t\t\t\t'hsl( 60, 100%, 50% )',\n\t\t\t\t\t'hsl( 120, 100%, 50% )',\n\t\t\t\t\t'hsl( 180, 100%, 47% )',\n\t\t\t\t\t'hsl( 240, 100%, 58% )',\n\t\t\t\t\t'hsl( 300, 100%, 50% )',\n\t\t\t\t\t'hsl( 360, 100%, 50% )'\n\t\t\t\t]\n\t\t\t},\n\t\t};\n\n\t\t// Set container\n\t\tthis._container = container || document.body;\n\n\t\t// Make sure we have minimal width and height dimensions in case of an inline container\n\t\tthis._defaultWidth  = this._container.clientWidth  || 640;\n\t\tthis._defaultHeight = this._container.clientHeight || 270;\n\n\t\t// Use audio context provided by user, or create a new one\n\n\t\tlet audioCtx;\n\n\t\tif ( options.source && ( audioCtx = options.source.context ) ) {\n\t\t\t// get audioContext from provided source audioNode\n\t\t}\n\t\telse if ( audioCtx = options.audioCtx ) {\n\t\t\t// use audioContext provided by user\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\taudioCtx = new ( window.AudioContext || window.webkitAudioContext )();\n\t\t\t}\n\t\t\tcatch( err ) {\n\t\t\t\tthrow new AudioMotionError( 'ERR_AUDIO_CONTEXT_FAIL', 'Could not create audio context. Web Audio API not supported?' );\n\t\t\t}\n\t\t}\n\n\t\t// make sure audioContext is valid\n\t\tif ( ! audioCtx.createGain )\n\t\t\tthrow new AudioMotionError( 'ERR_INVALID_AUDIO_CONTEXT', 'Provided audio context is not valid' );\n\n\t\t/*\n\t\t\tConnection routing:\n\t\t\t===================\n\n\t\t\tfor STEREO:                              +--->  analyzer[0]  ---+\n\t\t    \t                                     |                      |\n\t\t\t(source) --->  input  --->  splitter  ---+                      +--->  merger  --->  output  ---> (destination)\n\t\t    \t                                     |                      |\n\t\t        \t                                 +--->  analyzer[1]  ---+\n\n\t\t\tfor MONO:\n\n\t\t\t(source) --->  input  ----------------------->  analyzer[0]  --------------------->  output  ---> (destination)\n\n\t\t*/\n\n\t\t// create the analyzer nodes, channel splitter and merger, and gain nodes for input/output connections\n\t\tconst analyzer = this._analyzer = [ audioCtx.createAnalyser(), audioCtx.createAnalyser() ];\n\t\tconst splitter = this._splitter = audioCtx.createChannelSplitter(2);\n \t\tconst merger   = this._merger   = audioCtx.createChannelMerger(2);\n \t\tthis._input    = audioCtx.createGain();\n \t\tthis._output   = audioCtx.createGain();\n\n \t\t// initialize sources array and connect audio source if provided in the options\n\t\tthis._sources = [];\n\t\tif ( options.source )\n\t\t\tthis.connectInput( options.source );\n\n \t\t// connect splitter -> analyzers\n \t\tfor ( const i of [0,1] )\n\t\t\tsplitter.connect( analyzer[ i ], i );\n\n\t\t// connect merger -> output\n\t\tmerger.connect( this._output );\n\n\t\t// connect output -> destination (speakers)\n\t\tthis._outNodes = [];\n\t\tif ( options.connectSpeakers !== false )\n\t\t\tthis.connectOutput();\n\n\t\t// initialize object to save energy\n\t\tthis._energy = { val: 0, peak: 0, hold: 0 };\n\n\t\t// create analyzer canvas\n\t\tconst canvas = document.createElement('canvas');\n\t\tcanvas.style = 'max-width: 100%;';\n\t\tthis._canvasCtx = canvas.getContext('2d');\n\n\t\t// create auxiliary canvases for the X-axis and radial scale labels\n\t\tfor ( const ctx of [ '_scaleX', '_scaleR' ] )\n\t\t\tthis[ ctx ] = document.createElement('canvas').getContext('2d');\n\n\t\t// set fullscreen element (defaults to canvas)\n\t\tthis._fsEl = options.fsElement || canvas;\n\n\t\t// Update canvas size on container / window resize and fullscreen events\n\n\t\t// Fullscreen changes are handled quite differently across browsers:\n\t\t// 1. Chromium browsers will trigger a `resize` event followed by a `fullscreenchange`\n\t\t// 2. Firefox triggers the `fullscreenchange` first and then the `resize`\n\t\t// 3. Chrome on Android (TV) won't trigger a `resize` event, only `fullscreenchange`\n\t\t// 4. Safari won't trigger `fullscreenchange` events at all, and on iPadOS the `resize`\n\t\t//    event is triggered **on the window** only (last tested on iPadOS 14)\n\n\t\t// helper function for resize events\n\t\tconst onResize = () => {\n\t\t\tif ( ! this._fsTimeout ) {\n\t\t\t\t// delay the resize to prioritize a possible following `fullscreenchange` event\n\t\t\t\tthis._fsTimeout = window.setTimeout( () => {\n\t\t\t\t\tif ( ! this._fsChanging ) {\n\t\t\t\t\t\tthis._setCanvas('resize');\n\t\t\t\t\t\tthis._fsTimeout = 0;\n\t\t\t\t\t}\n\t\t\t\t}, 60 );\n\t\t\t}\n\t\t}\n\n\t\t// if browser supports ResizeObserver, listen for resize on the container\n\t\tif ( window.ResizeObserver ) {\n\t\t\tconst resizeObserver = new ResizeObserver( onResize );\n\t\t\tresizeObserver.observe( this._container );\n\t\t}\n\n\t\t// listen for resize events on the window - required for fullscreen on iPadOS\n\t\twindow.addEventListener( 'resize', onResize );\n\n\t\t// listen for fullscreenchange events on the canvas - not available on Safari\n\t\tcanvas.addEventListener( 'fullscreenchange', () => {\n\t\t\t// set flag to indicate a fullscreen change in progress\n\t\t\tthis._fsChanging = true;\n\n\t\t\t// if there is a scheduled resize event, clear it\n\t\t\tif ( this._fsTimeout )\n\t\t\t\twindow.clearTimeout( this._fsTimeout );\n\n\t\t\t// update the canvas\n\t\t\tthis._setCanvas('fschange');\n\n\t\t\t// delay clearing the flag to prevent any shortly following resize event\n\t\t\tthis._fsTimeout = window.setTimeout( () => {\n\t\t\t\tthis._fsChanging = false;\n\t\t\t\tthis._fsTimeout = 0;\n\t\t\t}, 60 );\n\t\t});\n\n\t\t// Resume audio context if in suspended state (browsers' autoplay policy)\n\t\tconst unlockContext = () => {\n\t\t\tif ( audioCtx.state == 'suspended' )\n\t\t\t\taudioCtx.resume();\n\t\t\twindow.removeEventListener( 'click', unlockContext );\n\t\t}\n\t\twindow.addEventListener( 'click', unlockContext );\n\n\t\t// initialize internal variables\n\t\tthis._calcAux();\n\n\t\t// Set configuration options and use defaults for any missing properties\n\t\tthis._setProps( options, true );\n\n\t\t// add canvas to the container\n\t\tif ( this.useCanvas )\n\t\t\tthis._container.appendChild( canvas );\n\n\t\t// Finish canvas setup\n\t\tthis._ready = true;\n\t\tthis._setCanvas('create');\n\t}\n\n\t/**\n\t * ==========================================================================\n\t *\n\t * PUBLIC PROPERTIES GETTERS AND SETTERS\n\t *\n\t * ==========================================================================\n\t */\n\n\n\tget alphaBars() {\n\t\treturn this._alphaBars;\n\t}\n\tset alphaBars( value ) {\n\t\tthis._alphaBars = !! value;\n\t\tthis._calcAux();\n\t}\n\n\tget barSpace() {\n\t\treturn this._barSpace;\n\t}\n\tset barSpace( value ) {\n\t\tthis._barSpace = +value || 0;\n\t\tthis._calcAux();\n\t}\n\n\tget fftSize() {\n\t\treturn this._analyzer[0].fftSize;\n\t}\n\tset fftSize( value ) {\n\t\tfor ( const i of [0,1] )\n\t\t\tthis._analyzer[ i ].fftSize = value;\n\t\tconst binCount = this._analyzer[0].frequencyBinCount;\n\t\tthis._fftData = [ new Uint8Array( binCount ), new Uint8Array( binCount ) ];\n\t\tthis._calcBars();\n\t}\n\n\tget gradient() {\n\t\treturn this._gradient;\n\t}\n\tset gradient( value ) {\n\t\tif ( ! this._gradients.hasOwnProperty( value ) )\n\t\t\tthrow new AudioMotionError( 'ERR_UNKNOWN_GRADIENT', `Unknown gradient: '${value}'` );\n\n\t\tthis._gradient = value;\n\t\tthis._makeGrad();\n\t}\n\n\tget height() {\n\t\treturn this._height;\n\t}\n\tset height( h ) {\n\t\tthis._height = h;\n\t\tthis._setCanvas('user');\n\t}\n\n\tget ledBars() {\n\t\treturn this._showLeds;\n\t}\n\tset ledBars( value ) {\n\t\tthis._showLeds = !! value;\n\t\tthis._calcAux();\n\t}\n\n\tget loRes() {\n\t\treturn this._loRes;\n\t}\n\tset loRes( value ) {\n\t\tthis._loRes = !! value;\n\t\tthis._setCanvas('lores');\n\t}\n\n\tget lumiBars() {\n\t\treturn this._lumiBars;\n\t}\n\tset lumiBars( value ) {\n\t\tthis._lumiBars = !! value;\n\t\tthis._calcAux();\n\t\tthis._calcLeds();\n\t\tthis._makeGrad();\n\t}\n\n\tget maxDecibels() {\n\t\treturn this._analyzer[0].maxDecibels;\n\t}\n\tset maxDecibels( value ) {\n\t\tfor ( const i of [0,1] )\n\t\t\tthis._analyzer[ i ].maxDecibels = value;\n\t}\n\n\tget maxFreq() {\n\t\treturn this._maxFreq;\n\t}\n\tset maxFreq( value ) {\n\t\tif ( value < 1 )\n\t\t\tthrow new AudioMotionError( 'ERR_FREQUENCY_TOO_LOW', `Frequency values must be >= 1` );\n\t\telse {\n\t\t\tthis._maxFreq = value;\n\t\t\tthis._calcBars();\n\t\t}\n\t}\n\n\tget minDecibels() {\n\t\treturn this._analyzer[0].minDecibels;\n\t}\n\tset minDecibels( value ) {\n\t\tfor ( const i of [0,1] )\n\t\t\tthis._analyzer[ i ].minDecibels = value;\n\t}\n\n\tget minFreq() {\n\t\treturn this._minFreq;\n\t}\n\tset minFreq( value ) {\n\t\tif ( value < 1 )\n\t\t\tthrow new AudioMotionError( 'ERR_FREQUENCY_TOO_LOW', `Frequency values must be >= 1` );\n\t\telse {\n\t\t\tthis._minFreq = value;\n\t\t\tthis._calcBars();\n\t\t}\n\t}\n\n\tget mirror() {\n\t\treturn this._mirror;\n\t}\n\tset mirror( value ) {\n\t\tthis._mirror = Math.sign( value ) | 0; // ensure only -1, 0 or 1\n\t\tthis._calcAux();\n\t\tthis._calcBars();\n\t\tthis._makeGrad();\n\t}\n\n\tget mode() {\n\t\treturn this._mode;\n\t}\n\tset mode( value ) {\n\t\tconst mode = value | 0;\n\t\tif ( mode >= 0 && mode <= 10 && mode != 9 ) {\n\t\t\tthis._mode = mode;\n\t\t\tthis._calcAux();\n\t\t\tthis._calcBars();\n\t\t\tthis._makeGrad();\n\t\t}\n\t\telse\n\t\t\tthrow new AudioMotionError( 'ERR_INVALID_MODE', `Invalid mode: ${value}` );\n\t}\n\n\tget outlineBars() {\n\t\treturn this._outlineBars;\n\t}\n\tset outlineBars( value ) {\n\t\tthis._outlineBars = !! value;\n\t\tthis._calcAux();\n\t}\n\n\tget radial() {\n\t\treturn this._radial;\n\t}\n\tset radial( value ) {\n\t\tthis._radial = !! value;\n\t\tthis._calcAux();\n\t\tthis._calcBars();\n\t\tthis._makeGrad();\n\t}\n\n\tget reflexRatio() {\n\t\treturn this._reflexRatio;\n\t}\n\tset reflexRatio( value ) {\n\t\tvalue = +value || 0;\n\t\tif ( value < 0 || value >= 1 )\n\t\t\tthrow new AudioMotionError( 'ERR_REFLEX_OUT_OF_RANGE', `Reflex ratio must be >= 0 and < 1` );\n\t\telse {\n\t\t\tthis._reflexRatio = value;\n\t\t\tthis._calcAux();\n\t\t\tthis._makeGrad();\n\t\t\tthis._calcLeds();\n\t\t}\n\t}\n\n\t// DEPRECATED - use ledBars instead\n\tget showLeds() {\n\t\treturn this.ledBars;\n\t}\n\tset showLeds( value ) {\n\t\tthis.ledBars = value;\n\t}\n\n\tget smoothing() {\n\t\treturn this._analyzer[0].smoothingTimeConstant;\n\t}\n\tset smoothing( value ) {\n\t\tfor ( const i of [0,1] )\n\t\t\tthis._analyzer[ i ].smoothingTimeConstant = value;\n\t}\n\n\tget spinSpeed() {\n\t\treturn this._spinSpeed;\n\t}\n\tset spinSpeed( value ) {\n\t\tvalue = +value || 0;\n\t\tif ( this._spinSpeed === undefined || value == 0 )\n\t\t\tthis._spinAngle = -HALF_PI; // initialize or reset the rotation angle\n\t\tthis._spinSpeed = value;\n\t}\n\n\tget splitGradient() {\n\t\treturn this._splitGradient;\n\t}\n\tset splitGradient( value ) {\n\t\tthis._splitGradient = !! value;\n\t\tthis._makeGrad();\n\t}\n\n\tget stereo() {\n\t\treturn this._stereo;\n\t}\n\tset stereo( value ) {\n\t\tthis._stereo = !! value;\n\n\t\t// update node connections\n\t\tthis._input.disconnect();\n\t\tthis._input.connect( this._stereo ? this._splitter : this._analyzer[0] );\n\t\tthis._analyzer[0].disconnect();\n\t\tif ( this._outNodes.length ) // connect analyzer only if the output is connected to other nodes\n\t\t\tthis._analyzer[0].connect( this._stereo ? this._merger : this._output );\n\n\t\t// update properties affected by stereo\n\t\tthis._calcAux();\n\t\tthis._createScales();\n\t\tthis._calcLeds();\n\t\tthis._makeGrad();\n\t}\n\n\tget volume() {\n\t\treturn this._output.gain.value;\n\t}\n\tset volume( value ) {\n\t\tthis._output.gain.value = value;\n\t}\n\n\tget width() {\n\t\treturn this._width;\n\t}\n\tset width( w ) {\n\t\tthis._width = w;\n\t\tthis._setCanvas('user');\n\t}\n\n\t// Read only properties\n\n\tget audioCtx() {\n\t\treturn this._input.context;\n\t}\n\tget canvas() {\n\t\treturn this._canvasCtx.canvas;\n\t}\n\tget canvasCtx() {\n\t\treturn this._canvasCtx;\n\t}\n\tget connectedSources() {\n\t\treturn this._sources;\n\t}\n\tget connectedTo() {\n\t\treturn this._outNodes;\n\t}\n\tget energy() { // DEPRECATED - use getEnergy() instead\n\t\treturn this.getEnergy();\n\t}\n\tget fps() {\n\t\treturn this._fps;\n\t}\n\tget fsHeight() {\n\t\treturn this._fsHeight;\n\t}\n\tget fsWidth() {\n\t\treturn this._fsWidth;\n\t}\n\tget isAlphaBars() {\n\t\treturn this._isAlphaBars;\n\t}\n\tget isFullscreen() {\n\t\treturn ( document.fullscreenElement || document.webkitFullscreenElement ) === this._fsEl;\n\t}\n\tget isLedBars() {\n\t\treturn this._isLedDisplay;\n\t}\n\tget isLedDisplay() { // DEPRECATED - use isLedBars instead\n\t\treturn this.isLedBars;\n\t}\n\tget isLumiBars() {\n\t\treturn this._isLumiBars;\n\t}\n\tget isOctaveBands() {\n\t\treturn this._isOctaveBands;\n\t}\n\tget isOn() {\n\t\treturn this._runId !== undefined;\n\t}\n\tget isOutlineBars() {\n\t\treturn this._isOutline;\n\t}\n\tget peakEnergy() { // DEPRECATED - use getEnergy('peak') instead\n\t\treturn this.getEnergy('peak');\n\t}\n\tget pixelRatio() {\n\t\treturn this._pixelRatio;\n\t}\n\tstatic get version() {\n\t\treturn VERSION;\n\t}\n\n\t/**\n\t * ==========================================================================\n     *\n\t * PUBLIC METHODS\n\t *\n\t * ==========================================================================\n\t */\n\n\t/**\n\t * Connects an HTML media element or audio node to the analyzer\n\t *\n\t * @param {object} an instance of HTMLMediaElement or AudioNode\n\t * @returns {object} a MediaElementAudioSourceNode object if created from HTML element, or the same input object otherwise\n\t */\n\tconnectInput( source ) {\n\t\tconst isHTML = source instanceof HTMLMediaElement;\n\n\t\tif ( ! ( isHTML || source.connect ) )\n\t\t\tthrow new AudioMotionError( 'ERR_INVALID_AUDIO_SOURCE', 'Audio source must be an instance of HTMLMediaElement or AudioNode' );\n\n\t\t// if source is an HTML element, create an audio node for it; otherwise, use the provided audio node\n\t\tconst node = isHTML ? this.audioCtx.createMediaElementSource( source ) : source;\n\n\t\tif ( ! this._sources.includes( node ) ) {\n\t\t\tnode.connect( this._input );\n\t\t\tthis._sources.push( node );\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Connects the analyzer output to another audio node\n\t *\n\t * @param [{object}] an AudioNode; if undefined, the output is connected to the audio context destination (speakers)\n\t */\n\tconnectOutput( node = this.audioCtx.destination ) {\n\t\tif ( this._outNodes.includes( node ) )\n\t\t\treturn;\n\n\t\tthis._output.connect( node );\n\t\tthis._outNodes.push( node );\n\n\t\t// when connecting the first node, also connect the analyzer nodes to the merger / output nodes\n\t\tif ( this._outNodes.length == 1 ) {\n\t\t\tfor ( const i of [0,1] )\n\t\t\t\tthis._analyzer[ i ].connect( ( ! this._stereo && ! i ? this._output : this._merger ), 0, i );\n\t\t}\n\t}\n\n\t/**\n\t * Disconnects audio sources from the analyzer\n\t *\n\t * @param [{object|array}] a connected AudioNode object or an array of such objects; if undefined, all connected nodes are disconnected\n\t */\n\tdisconnectInput( sources ) {\n\t\tif ( ! sources )\n\t\t\tsources = Array.from( this._sources );\n\t\telse if ( ! Array.isArray( sources ) )\n\t\t\tsources = [ sources ];\n\n\t\tfor ( const node of sources ) {\n\t\t\tconst idx = this._sources.indexOf( node );\n\t\t\tif ( idx >= 0 ) {\n\t\t\t\tnode.disconnect( this._input );\n\t\t\t\tthis._sources.splice( idx, 1 );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Disconnects the analyzer output from other audio nodes\n\t *\n\t * @param [{object}] a connected AudioNode object; if undefined, all connected nodes are disconnected\n\t */\n\tdisconnectOutput( node ) {\n\t\tif ( node && ! this._outNodes.includes( node ) )\n\t\t\treturn;\n\n\t\tthis._output.disconnect( node );\n\t\tthis._outNodes = node ? this._outNodes.filter( e => e !== node ) : [];\n\n\t\t// if disconnected from all nodes, also disconnect the analyzer nodes so they keep working on Chromium\n\t\t// see https://github.com/hvianna/audioMotion-analyzer/issues/13#issuecomment-808764848\n\t\tif ( this._outNodes.length == 0 ) {\n\t\t\tfor ( const i of [0,1] )\n\t\t\t\tthis._analyzer[ i ].disconnect();\n\t\t}\n\t}\n\n\t/**\n\t * Returns analyzer bars data\n     *\n\t * @returns {array}\n\t */\n\tgetBars() {\n\t\treturn Array.from( this._bars, ( { posX, freqLo, freqHi, hold, peak, value } ) => ( { posX, freqLo, freqHi, hold, peak, value } ) );\n\t}\n\n\t/**\n\t * Returns the energy of a frequency, or average energy of a range of frequencies\n\t *\n\t * @param [{number|string}] single or initial frequency (Hz), or preset name; if undefined, returns the overall energy\n\t * @param [{number}] ending frequency (Hz)\n\t * @returns {number|null} energy value (0 to 1) or null, if the specified preset is unknown\n\t */\n\tgetEnergy( startFreq, endFreq ) {\n\t\tif ( startFreq === undefined )\n\t\t\treturn this._energy.val;\n\n\t\t// if startFreq is a string, check for presets\n\t\tif ( startFreq != +startFreq ) {\n\t\t\tif ( startFreq == 'peak' )\n\t\t\t\treturn this._energy.peak;\n\n\t\t\tconst presets = {\n\t\t\t\tbass:    [ 20, 250 ],\n\t\t\t\tlowMid:  [ 250, 500 ],\n\t\t\t\tmid:     [ 500, 2e3 ],\n\t\t\t\thighMid: [ 2e3, 4e3 ],\n\t\t\t\ttreble:  [ 4e3, 16e3 ]\n\t\t\t}\n\n\t\t\tif ( ! presets[ startFreq ] )\n\t\t\t\treturn null;\n\n\t\t\t[ startFreq, endFreq ] = presets[ startFreq ];\n\t\t}\n\n\t\tconst startBin = this._freqToBin( startFreq ),\n\t\t      endBin   = endFreq ? this._freqToBin( endFreq ) : startBin,\n\t\t      chnCount = this._stereo + 1;\n\n\t\tlet energy = 0;\n\t\tfor ( let channel = 0; channel < chnCount; channel++ ) {\n\t\t\tfor ( let i = startBin; i <= endBin; i++ )\n\t\t\t\tenergy += this._fftData[ channel ][ i ];\n\t\t}\n\n\t\treturn energy / ( endBin - startBin + 1 ) / chnCount / 255;\n\t}\n\n\t/**\n\t * Registers a custom gradient\n\t *\n\t * @param {string} name\n\t * @param {object} options\n\t */\n\tregisterGradient( name, options ) {\n\t\tif ( typeof name !== 'string' || name.trim().length == 0 )\n\t\t\tthrow new AudioMotionError( 'ERR_GRADIENT_INVALID_NAME', 'Gradient name must be a non-empty string' );\n\n\t\tif ( typeof options !== 'object' )\n\t\t\tthrow new AudioMotionError( 'ERR_GRADIENT_NOT_AN_OBJECT', 'Gradient options must be an object' );\n\n\t\tif ( options.colorStops === undefined || options.colorStops.length < 2 )\n\t\t\tthrow new AudioMotionError( 'ERR_GRADIENT_MISSING_COLOR', 'Gradient must define at least two colors' );\n\n\t\tthis._gradients[ name ] = {\n\t\t\tbgColor:    options.bgColor || '#111',\n\t\t\tdir:        options.dir,\n\t\t\tcolorStops: options.colorStops\n\t\t};\n\n\t\t// if the registered gradient is the current one, regenerate it\n\t\tif ( name == this._gradient )\n\t\t\tthis._makeGrad();\n\t}\n\n\t/**\n\t * Set dimensions of analyzer's canvas\n\t *\n\t * @param {number} w width in pixels\n\t * @param {number} h height in pixels\n\t */\n\tsetCanvasSize( w, h ) {\n\t\tthis._width = w;\n\t\tthis._height = h;\n\t\tthis._setCanvas('user');\n\t}\n\n\t/**\n\t * Set desired frequency range\n\t *\n\t * @param {number} min lowest frequency represented in the x-axis\n\t * @param {number} max highest frequency represented in the x-axis\n\t */\n\tsetFreqRange( min, max ) {\n\t\tif ( min < 1 || max < 1 )\n\t\t\tthrow new AudioMotionError( 'ERR_FREQUENCY_TOO_LOW', `Frequency values must be >= 1` );\n\t\telse {\n\t\t\tthis._minFreq = Math.min( min, max );\n\t\t\tthis._maxFreq = Math.max( min, max );\n\t\t\tthis._calcBars();\n\t\t}\n\t}\n\n\t/**\n\t * Set custom parameters for LED effect\n\t * If called with no arguments or if any property is invalid, clears any previous custom parameters\n\t *\n\t * @param {object} [params]\n\t */\n\tsetLedParams( params ) {\n\t\tlet maxLeds, spaceV, spaceH;\n\n\t\t// coerce parameters to Number; `NaN` results are rejected in the condition below\n\t\tif ( params ) {\n\t\t\tmaxLeds = params.maxLeds | 0, // ensure integer\n\t\t\tspaceV  = +params.spaceV,\n\t\t\tspaceH  = +params.spaceH;\n\t\t}\n\n\t\tthis._ledParams = maxLeds > 0 && spaceV > 0 && spaceH >= 0 ? [ maxLeds, spaceV, spaceH ] : undefined;\n\t\tthis._calcLeds();\n\t}\n\n\t/**\n\t * Shorthand function for setting several options at once\n\t *\n\t * @param {object} options\n\t */\n\tsetOptions( options ) {\n\t\tthis._setProps( options );\n\t}\n\n\t/**\n\t * Adjust the analyzer's sensitivity\n\t *\n\t * @param {number} min minimum decibels value\n\t * @param {number} max maximum decibels value\n\t */\n\tsetSensitivity( min, max ) {\n\t\tfor ( const i of [0,1] ) {\n\t\t\tthis._analyzer[ i ].minDecibels = Math.min( min, max );\n\t\t\tthis._analyzer[ i ].maxDecibels = Math.max( min, max );\n\t\t}\n\t}\n\n\t/**\n\t * Start / stop canvas animation\n\t *\n\t * @param {boolean} [value] if undefined, inverts the current status\n\t * @returns {boolean} resulting status after the change\n\t */\n\ttoggleAnalyzer( value ) {\n\t\tconst started = this.isOn;\n\n\t\tif ( value === undefined )\n\t\t\tvalue = ! started;\n\n\t\tif ( started && ! value ) {\n\t\t\tcancelAnimationFrame( this._runId );\n\t\t\tthis._runId = undefined;\n\t\t}\n\t\telse if ( ! started && value ) {\n\t\t\tthis._frame = this._fps = 0;\n\t\t\tthis._time = performance.now();\n\t\t\tthis._runId = requestAnimationFrame( timestamp => this._draw( timestamp ) );\n\t\t}\n\n\t\treturn this.isOn;\n\t}\n\n\t/**\n\t * Toggles canvas full-screen mode\n\t */\n\ttoggleFullscreen() {\n\t\tif ( this.isFullscreen ) {\n\t\t\tif ( document.exitFullscreen )\n\t\t\t\tdocument.exitFullscreen();\n\t\t\telse if ( document.webkitExitFullscreen )\n\t\t\t\tdocument.webkitExitFullscreen();\n\t\t}\n\t\telse {\n\t\t\tconst fsEl = this._fsEl;\n\t\t\tif ( fsEl.requestFullscreen )\n\t\t\t\tfsEl.requestFullscreen();\n\t\t\telse if ( fsEl.webkitRequestFullscreen )\n\t\t\t\tfsEl.webkitRequestFullscreen();\n\t\t}\n\t}\n\n\t/**\n\t * ==========================================================================\n\t *\n\t * PRIVATE METHODS\n\t *\n\t * ==========================================================================\n\t */\n\n\t/**\n\t * Calculate auxiliary values and flags\n\t */\n\t_calcAux() {\n\t\tconst canvas   = this.canvas,\n\t\t\t  isRadial = this._radial,\n\t\t\t  isDual   = this._stereo && ! isRadial,\n\t\t\t  centerX  = canvas.width >> 1;\n\n\t\tthis._radius         = Math.min( canvas.width, canvas.height ) * ( this._stereo ? .375 : .125 ) | 0;\n\t\tthis._barSpacePx     = Math.min( this._barWidth - 1, ( this._barSpace > 0 && this._barSpace < 1 ) ? this._barWidth * this._barSpace : this._barSpace );\n\t\tthis._isOctaveBands  = this._mode % 10 != 0;\n\t\tthis._isLedDisplay   = this._showLeds && this._isOctaveBands && ! isRadial;\n\t\tthis._isLumiBars     = this._lumiBars && this._isOctaveBands && ! isRadial;\n\t\tthis._isAlphaBars    = this._alphaBars && ! this._isLumiBars && this._mode != 10;\n\t\tthis._isOutline      = this._outlineBars && this._isOctaveBands && ! this._isLumiBars && ! this._isLedDisplay;\n\t\tthis._maximizeLeds   = ! this._stereo || this._reflexRatio > 0 && ! this._isLumiBars;\n\n\t\tthis._channelHeight  = canvas.height - ( isDual && ! this._isLedDisplay ? .5 : 0 ) >> isDual;\n\t\tthis._analyzerHeight = this._channelHeight * ( this._isLumiBars || isRadial ? 1 : 1 - this._reflexRatio ) | 0;\n\n\t\t// channelGap is **0** if isLedDisplay == true (LEDs already have spacing); **1** if canvas height is odd (windowed); **2** if it's even\n\t\t// TODO: improve this, make it configurable?\n\t\tthis._channelGap     = isDual ? canvas.height - this._channelHeight * 2 : 0;\n\n\t\tthis._analyzerWidth  = canvas.width - centerX * ( this._mirror != 0 );\n\t\tthis._initialX       = centerX * ( this._mirror == -1 && ! isRadial );\n\t}\n\n\t/**\n\t * Precalculate the actual X-coordinate on screen for each analyzer bar\n\t */\n\t_calcBars() {\n\t\t/*\n\t \t   Since the frequency scale is logarithmic, each position in the X-axis actually represents a power of 10.\n\t \t   To improve performace, the position of each frequency is calculated in advance and stored in an array.\n\t \t   Canvas space usage is optimized to accommodate exactly the frequency range the user needs.\n\t \t   Positions need to be recalculated whenever the frequency range, FFT size or canvas size change.\n\n\t \t                                +-------------------------- canvas --------------------------+\n\t \t                                |                                                            |\n\t \t      |-------------------|-----|-------------|-------------------!-------------------|------|------------|\n\t \t      1                  10     |            100                  1K                 10K     |           100K (Hz)\n\t \t   (10^0)              (10^1)   |          (10^2)               (10^3)              (10^4)   |          (10^5)\n\t \t                                |-------------|<--- logWidth ---->|--------------------------|\n\t \t                    minFreq--> 20                   (pixels)                                22K <--maxFreq\n\t \t                            (10^1.3)                                                     (10^4.34)\n\t \t                             minLog\n\t \t*/\n\n\t\tconst bars = this._bars = []; // initialize object property\n\n\t\tif ( ! this._ready )\n\t\t\treturn;\n\n\t\t// helper functions\n\t\tconst binToFreq = bin => bin * this.audioCtx.sampleRate / this.fftSize || 1; // returns 1 for bin 0\n\t\tconst barsPush  = ( posX, binLo, binHi, freqLo, freqHi, ratioLo, ratioHi ) => bars.push( { posX, binLo, binHi, freqLo, freqHi, ratioLo, ratioHi, peak: [0,0], hold: [0], value: [0] } );\n\n\t\tconst analyzerWidth = this._analyzerWidth,\n\t\t\t  initialX      = this._initialX,\n\t\t\t  maxFreq       = this._maxFreq,\n\t\t\t  minFreq       = this._minFreq;\n\n\t\tlet minLog,\tlogWidth;\n\n\t\tif ( this._isOctaveBands ) {\n\n\t\t\t// generate a 11-octave 24-tone equal tempered scale (16Hz to 33kHz)\n\n\t\t\t/*\n\t\t\t\tA simple linear interpolation is used to obtain an approximate amplitude value for the desired frequency\n\t\t\t\tfrom available FFT data, like so:\n\n\t\t\t\th = hLo + ( hHi - hLo ) * ( f - fLo ) / ( fHi - fLo )\n\t\t\t\t                         \\___________________________/\n\t\t\t\t                                       |\n\t\t\t\t                                     ratio\n\t\t\t\twhere:\n\n\t\t\t\tf   - desired frequency\n\t\t\t\th   - amplitude of desired frequency\n\t\t\t\tfLo - frequency represented by the lower FFT bin\n\t\t\t\tfHi - frequency represented by the higher FFT bin\n\t\t\t\thLo - amplitude of fLo\n\t\t\t\thHi - amplitude of fHi\n\n\t\t\t\tratio is calculated in advance here, to reduce computational complexity during real-time rendering in the _draw() function\n\t\t\t*/\n\n\t\t\tlet temperedScale = [];\n\n\t\t\tfor ( let octave = 0; octave < 11; octave++ ) {\n\t\t\t\tfor ( let note = 0; note < 24; note++ ) {\n\n\t\t\t\t\tconst freq     = C0 * ROOT24 ** ( octave * 24 + note ),\n\t\t\t\t\t\t  bin      = this._freqToBin( freq, 'floor' ),\n\t\t\t\t\t\t  binFreq  = binToFreq( bin ),\n\t\t\t\t\t\t  nextFreq = binToFreq( bin + 1 ),\n\t\t\t\t\t\t  ratio    = ( freq - binFreq ) / ( nextFreq - binFreq );\n\n\t\t\t\t\ttemperedScale.push( { freq, bin, ratio } );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// generate the frequency bands according to current analyzer settings\n\n\t\t\tconst steps = [0,1,2,3,4,6,8,12,24][ this._mode ]; // number of notes grouped per band for each mode\n\n\t\t\tfor ( let index = 0; index < temperedScale.length; index += steps ) {\n\t\t\t\tlet { freq: freqLo, bin: binLo, ratio: ratioLo } = temperedScale[ index ],             // band start\n\t\t\t\t\t{ freq: freqHi, bin: binHi, ratio: ratioHi } = temperedScale[ index + steps - 1 ]; // band end\n\n\t\t\t\tconst nBars   = bars.length,\n\t\t\t\t\t  prevBar = bars[ nBars - 1 ];\n\n\t\t\t\t// if the ending frequency is out of range, we're done here\n\t\t\t\tif ( freqHi > maxFreq || binHi >= this.fftSize / 2 ) {\n\t\t\t\t\tprevBar.binHi++;     // add an extra bin to the last bar, to fully include the last valid band\n\t\t\t\t\tprevBar.ratioHi = 0; // disable interpolation\n\t\t\t\t\tprevBar.freqHi = binToFreq( prevBar.binHi ); // update ending frequency\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// is the starting frequency in the selected range?\n\t\t\t\tif ( freqLo >= minFreq ) {\n\t\t\t\t\tif ( nBars > 0 ) {\n\t\t\t\t\t\tconst diff = binLo - prevBar.binHi;\n\n\t\t\t\t\t\t// check if we skipped any available FFT bins since the last bar\n\t\t\t\t\t\tif ( diff > 1 ) {\n\t\t\t\t\t\t\t// allocate half of the unused bins to the previous bar\n\t\t\t\t\t\t\tprevBar.binHi = binLo - ( diff >> 1 );\n\t\t\t\t\t\t\tprevBar.ratioHi = 0;\n\t\t\t\t\t\t\tprevBar.freqHi = binToFreq( prevBar.binHi ); // update ending frequency\n\n\t\t\t\t\t\t\t// if the previous bar doesn't share any bins with other bars, no need for interpolation\n\t\t\t\t\t\t\tif ( nBars > 1 && prevBar.binHi > prevBar.binLo && prevBar.binLo > bars[ nBars - 2 ].binHi ) {\n\t\t\t\t\t\t\t\tprevBar.ratioLo = 0;\n\t\t\t\t\t\t\t\tprevBar.freqLo = binToFreq( prevBar.binLo ); // update starting frequency\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// start the current bar at the bin following the last allocated bin\n\t\t\t\t\t\t\tbinLo = prevBar.binHi + 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if the lower bin is not shared with the ending frequency nor the previous bar, no need to interpolate it\n\t\t\t\t\t\tif ( binHi > binLo && binLo > prevBar.binHi ) {\n\t\t\t\t\t\t\tratioLo = 0;\n\t\t\t\t\t\t\tfreqLo = binToFreq( binLo );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbarsPush( 0, binLo, binHi, freqLo, freqHi, ratioLo, ratioHi );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis._barWidth = analyzerWidth / bars.length;\n\n\t\t\tbars.forEach( ( bar, index ) => bar.posX = initialX + index * this._barWidth );\n\n\t\t\tminLog = Math.log10( bars[0].freqLo );\n\t\t\tlogWidth = analyzerWidth / ( Math.log10( bars[ bars.length - 1 ].freqHi ) - minLog );\n\t\t}\n\t\telse {\n\n\t\t\t// Discrete frequencies modes\n\n\t\t\tthis._barWidth = 1;\n\n\t\t\tminLog = Math.log10( minFreq );\n\t\t\tlogWidth = analyzerWidth / ( Math.log10( maxFreq ) - minLog );\n\n\t\t\tconst minIndex = this._freqToBin( minFreq, 'floor' ),\n\t\t\t\t  maxIndex = this._freqToBin( maxFreq );\n\n\t \t\tlet lastPos = -999;\n\n\t\t\tfor ( let i = minIndex; i <= maxIndex; i++ ) {\n\t\t\t\tconst freq = binToFreq( i ), // frequency represented by this index\n\t\t\t\t\t  pos  = initialX + Math.round( logWidth * ( Math.log10( freq ) - minLog ) ); // avoid fractionary pixel values\n\n\t\t\t\t// if it's on a different X-coordinate, create a new bar for this frequency\n\t\t\t\tif ( pos > lastPos ) {\n\t\t\t\t\tbarsPush( pos, i, i, freq, freq, 0, 0 );\n\t\t\t\t\tlastPos = pos;\n\t\t\t\t} // otherwise, add this frequency to the last bar's range\n\t\t\t\telse if ( bars.length ) {\n\t\t\t\t\tbars[ bars.length - 1 ].binHi = i;\n\t\t\t\t\tbars[ bars.length - 1 ].freqHi = freq;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save these for scale generation\n\t\tthis._minLog = minLog;\n\t\tthis._logWidth = logWidth;\n\n\t\t// update internal variables\n\t\tthis._calcAux();\n\n\t\t// generate the X-axis and radial scales\n\t\tthis._createScales();\n\n\t\t// update LED properties\n\t\tthis._calcLeds();\n\t}\n\n\t/**\n\t * Calculate attributes for the vintage LEDs effect, based on visualization mode and canvas resolution\n\t */\n\t_calcLeds() {\n\t\tif ( ! this._isOctaveBands || ! this._ready )\n\t\t\treturn;\n\n\t\t// adjustment for high pixel-ratio values on low-resolution screens (Android TV)\n\t\tconst dPR = this._pixelRatio / ( window.devicePixelRatio > 1 && window.screen.height <= 540 ? 2 : 1 );\n\n\t\tconst params = [ [],\n\t\t\t[ 128,  3, .45  ], // mode 1\n\t\t\t[ 128,  4, .225 ], // mode 2\n\t\t\t[  96,  6, .225 ], // mode 3\n\t\t\t[  80,  6, .225 ], // mode 4\n\t\t\t[  80,  6, .125 ], // mode 5\n\t\t\t[  64,  6, .125 ], // mode 6\n\t\t\t[  48,  8, .125 ], // mode 7\n\t\t\t[  24, 16, .125 ], // mode 8\n\t\t];\n\n\t\t// use custom LED parameters if set, or the default parameters for the current mode\n\t\tconst customParams = this._ledParams,\n\t\t\t  [ maxLeds, spaceVRatio, spaceHRatio ] = customParams || params[ this._mode ];\n\n\t\tlet ledCount, spaceV,\n\t\t\tanalyzerHeight = this._analyzerHeight;\n\n\t\tif ( customParams ) {\n\t\t\tconst minHeight = 2 * dPR;\n\t\t\tlet blockHeight;\n\t\t\tledCount = maxLeds + 1;\n\t\t\tdo {\n\t\t\t\tledCount--;\n\t\t\t\tblockHeight = analyzerHeight / ledCount / ( 1 + spaceVRatio );\n\t\t\t\tspaceV = blockHeight * spaceVRatio;\n\t\t\t} while ( ( blockHeight < minHeight || spaceV < minHeight ) && ledCount > 1 );\n\t\t}\n\t\telse {\n\t\t\t// calculate vertical spacing - aim for the reference ratio, but make sure it's at least 2px\n\t\t\tconst refRatio = 540 / spaceVRatio;\n\t\t\tspaceV = Math.min( spaceVRatio * dPR, Math.max( 2, analyzerHeight / refRatio + .1 | 0 ) );\n\t\t}\n\n\t\t// remove the extra spacing below the last line of LEDs\n\t\tif ( this._maximizeLeds )\n\t\t\tanalyzerHeight += spaceV;\n\n\t\t// recalculate the number of leds, considering the effective spaceV\n\t\tif ( ! customParams )\n\t\t\tledCount = Math.min( maxLeds, analyzerHeight / ( spaceV * 2 ) | 0 );\n\n\t\tthis._leds = [\n\t\t\tledCount,\n\t\t\tspaceHRatio >= 1 ? spaceHRatio : this._barWidth * spaceHRatio, // spaceH\n\t\t\tspaceV,\n\t\t\tanalyzerHeight / ledCount - spaceV // ledHeight\n\t\t];\n\t}\n\n\t/**\n\t * Generate the X-axis and radial scales in auxiliary canvases\n\t */\n\t_createScales() {\n\t\tconst freqLabels  = [ 16, 31, 63, 125, 250, 500, 1000, 2000, 4000, 8000, 16000 ],\n\t\t\t  canvas      = this._canvasCtx.canvas,\n\t\t\t  scaleX      = this._scaleX,\n\t\t\t  scaleR      = this._scaleR,\n\t\t\t  canvasX     = scaleX.canvas,\n\t\t\t  canvasR     = scaleR.canvas,\n\t\t\t  scaleHeight = Math.min( canvas.width, canvas.height ) * .03 | 0; // circular scale height (radial mode)\n\n\t\t// in radial stereo mode, the scale is positioned exactly between both channels, by making the canvas a bit larger than the central diameter\n\t\tcanvasR.width = canvasR.height = ( this._radius << 1 ) + ( this._stereo * scaleHeight );\n\n\t\tconst radius  = canvasR.width >> 1, // this is also used as the center X and Y coordinates of the circular scale canvas\n\t\t\t  radialY = radius - scaleHeight * .7;\t// vertical position of text labels in the circular scale\n\n\t\t// helper function\n\t\tconst radialLabel = ( x, label ) => {\n\t\t\tconst angle  = TAU * ( x / canvas.width ),\n\t\t\t\t  adjAng = angle - HALF_PI, // rotate angles so 0 is at the top\n\t\t\t\t  posX   = radialY * Math.cos( adjAng ),\n\t\t\t\t  posY   = radialY * Math.sin( adjAng );\n\n\t\t\tscaleR.save();\n\t\t\tscaleR.translate( radius + posX, radius + posY );\n\t\t\tscaleR.rotate( angle );\n\t\t\tscaleR.fillText( label, 0, 0 );\n\t\t\tscaleR.restore();\n\t\t}\n\n\t\t// clear scale canvas\n\t\tcanvasX.width |= 0;\n\n\t\tscaleX.fillStyle = scaleR.strokeStyle = '#000c';\n\t\tscaleX.fillRect( 0, 0, canvasX.width, canvasX.height );\n\n\t\tscaleR.arc( radius, radius, radius - scaleHeight / 2, 0, TAU );\n\t\tscaleR.lineWidth = scaleHeight;\n\t\tscaleR.stroke();\n\n\t\tscaleX.fillStyle = scaleR.fillStyle = '#fff';\n\t\tscaleX.font = `${ canvasX.height >> 1 }px sans-serif`;\n\t\tscaleR.font = `${ scaleHeight >> 1 }px sans-serif`;\n\t\tscaleX.textAlign = scaleR.textAlign = 'center';\n\n\t\tfor ( const freq of freqLabels ) {\n\t\t\tconst label = ( freq >= 1000 ) ? `${ freq / 1000 }k` : freq,\n\t\t\t\t  x     = this._logWidth * ( Math.log10( freq ) - this._minLog );\n\n\t\t\tif ( x >= 0 && x <= this._analyzerWidth ) {\n\t\t\t\tscaleX.fillText( label, this._initialX + x, canvasX.height * .75 );\n\t\t\t\tif ( x < this._analyzerWidth ) // avoid wrapping-around the last label and overlapping the first one\n\t\t\t\t\tradialLabel( x, label );\n\n\t\t\t\tif ( this._mirror ) {\n\t\t\t\t\tscaleX.fillText( label, ( this._initialX || canvas.width ) - x, canvasX.height * .75 );\n\t\t\t\t\tif ( x > 10 ) // avoid overlapping of first labels on mirror mode\n\t\t\t\t\t\tradialLabel( -x, label );\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Redraw the canvas\n\t * this is called 60 times per second by requestAnimationFrame()\n\t */\n\t_draw( timestamp ) {\n\t\tconst ctx            = this._canvasCtx,\n\t\t\t  canvas         = ctx.canvas,\n\t\t\t  canvasX        = this._scaleX.canvas,\n\t\t\t  canvasR        = this._scaleR.canvas,\n\t\t\t  energy         = this._energy,\n\t\t\t  mode           = this._mode,\n\t\t\t  isAlphaBars    = this._isAlphaBars,\n\t\t\t  isLedDisplay   = this._isLedDisplay,\n\t\t\t  isLumiBars     = this._isLumiBars,\n\t\t\t  isOctaveBands  = this._isOctaveBands,\n\t\t\t  isOutline      = this._isOutline,\n\t\t\t  isRadial       = this._radial,\n\t\t\t  isStereo       = this._stereo,\n\t\t\t  lineWidth      = +this.lineWidth, // make sure the damn thing is a number!\n\t\t\t  mirrorMode     = this._mirror,\n\t\t\t  channelHeight  = this._channelHeight,\n\t\t\t  channelGap     = this._channelGap,\n\t\t\t  analyzerHeight = this._analyzerHeight,\n\t\t\t  analyzerWidth  = isRadial ? canvas.width : this._analyzerWidth,\n\t\t\t  initialX       = this._initialX,\n\t\t\t  finalX         = initialX + analyzerWidth,\n\t\t\t  centerX        = canvas.width >> 1,\n\t\t\t  centerY        = canvas.height >> 1,\n\t\t\t  radius         = this._radius,\n\t\t\t  maxBarHeight   = isRadial ? Math.min( centerX, centerY ) - radius : analyzerHeight,\n\t\t\t  useCanvas      = this.useCanvas;\n\n\t\tif ( energy.val > 0 )\n\t\t\tthis._spinAngle += this._spinSpeed * RPM;\n\n\t\tconst strokeIf = flag => {\n\t\t\tif ( flag && lineWidth ) {\n\t\t\t\tconst alpha = ctx.globalAlpha;\n\t\t\t\tctx.globalAlpha = 1;\n\t\t\t\tctx.stroke();\n\t\t\t\tctx.globalAlpha = alpha;\n\t\t\t}\n\t\t}\n\n\t\t// helper function - convert planar X,Y coordinates to radial coordinates\n\t\tconst radialXY = ( x, y, dir ) => {\n\t\t\tconst height = radius + y,\n\t\t\t\t  angle  = dir * TAU * ( x / canvas.width ) + this._spinAngle;\n\n\t\t\treturn [ centerX + height * Math.cos( angle ), centerY + height * Math.sin( angle ) ];\n\t\t}\n\n\t\t// helper function - draw a polygon of width `w` and height `h` at (x,y) in radial mode\n\t\tconst radialPoly = ( x, y, w, h, stroke ) => {\n\t\t\tctx.beginPath();\n\t\t\tfor ( const dir of ( mirrorMode ? [1,-1] : [1] ) ) {\n\t\t\t\tctx.moveTo( ...radialXY( x, y, dir ) );\n\t\t\t\tctx.lineTo( ...radialXY( x, y + h, dir ) );\n\t\t\t\tctx.lineTo( ...radialXY( x + w, y + h, dir ) );\n\t\t\t\tctx.lineTo( ...radialXY( x + w, y, dir ) );\n\t\t\t}\n\n\t\t\tstrokeIf( stroke );\n\t\t\tctx.fill();\n\t\t}\n\n\t\t// LED attributes and helper function for bar height calculation\n\t\tconst [ ledCount, ledSpaceH, ledSpaceV, ledHeight ] = this._leds || [];\n\t\tconst ledPosY = height => ( height * ledCount | 0 ) * ( ledHeight + ledSpaceV ) - ledSpaceV;\n\n\t\t// select background color\n\t\tconst bgColor = ( ! this.showBgColor || isLedDisplay && ! this.overlay ) ? '#000' : this._gradients[ this._gradient ].bgColor;\n\n\t\t// compute the effective bar width, considering the selected bar spacing\n\t\t// if led effect is active, ensure at least the spacing from led definitions\n\t\tlet width = this._barWidth - ( ! isOctaveBands ? 0 : Math.max( isLedDisplay ? ledSpaceH : 0, this._barSpacePx ) );\n\n\t\t// make sure width is integer for pixel accurate calculation, when no bar spacing is required\n\t\tif ( this._barSpace == 0 && ! isLedDisplay )\n\t\t\twidth |= 0;\n\n\t\tlet currentEnergy = 0;\n\n\t\tconst nBars = this._bars.length;\n\n\t\tfor ( let channel = 0; channel < isStereo + 1; channel++ ) {\n\n\t\t\tconst channelTop     = channelHeight * channel + channelGap * channel,\n\t\t\t\t  channelBottom  = channelTop + channelHeight,\n\t\t\t\t  analyzerBottom = channelTop + analyzerHeight - ( isLedDisplay && ! this._maximizeLeds ? ledSpaceV : 0 );\n\n\t\t\tif ( useCanvas ) {\n\t\t\t\t// clear the channel area, if in overlay mode\n\t\t\t\t// this is done per channel to clear any residue below 0 off the top channel (especially in line graph mode with lineWidth > 1)\n\t\t\t\tif ( this.overlay )\n\t\t\t\t\tctx.clearRect( 0, channelTop - channelGap, canvas.width, channelHeight + channelGap );\n\n\t\t\t\t// fill the analyzer background if needed (not overlay or overlay + showBgColor)\n\t\t\t\tif ( ! this.overlay || this.showBgColor ) {\n\t\t\t\t\tif ( this.overlay )\n\t\t\t\t\t\tctx.globalAlpha = this.bgAlpha;\n\n\t\t\t\t\tctx.fillStyle = bgColor;\n\n\t\t\t\t\t// exclude the reflection area when overlay is true and reflexAlpha == 1 (avoids alpha over alpha difference, in case bgAlpha < 1)\n\t\t\t\t\tif ( ! isRadial || channel == 0 )\n\t\t\t\t\t\tctx.fillRect( initialX, channelTop - channelGap, analyzerWidth, ( this.overlay && this.reflexAlpha == 1 ? analyzerHeight : channelHeight ) + channelGap );\n\n\t\t\t\t\tctx.globalAlpha = 1;\n\t\t\t\t}\n\n\t\t\t\t// draw dB scale (Y-axis)\n\t\t\t\tif ( this.showScaleY && ! isLumiBars && ! isRadial ) {\n\t\t\t\t\tconst scaleWidth = canvasX.height,\n\t\t\t\t\t\t  fontSize   = scaleWidth >> 1,\n\t\t\t\t\t\t  mindB      = this._analyzer[0].minDecibels,\n\t\t\t\t\t\t  maxdB      = this._analyzer[0].maxDecibels,\n\t\t\t\t\t\t  interval   = analyzerHeight / ( maxdB - mindB );\n\n\t\t\t\t\tctx.fillStyle = '#888';\n\t\t\t\t\tctx.font = `${fontSize}px sans-serif`;\n\t\t\t\t\tctx.textAlign = 'right';\n\t\t\t\t\tctx.lineWidth = 1;\n\n\t\t\t\t\tfor ( let db = maxdB; db > mindB; db -= 5 ) {\n\t\t\t\t\t\tconst posY = channelTop + ( maxdB - db ) * interval,\n\t\t\t\t\t\t\t  even = ( db % 2 == 0 ) | 0;\n\n\t\t\t\t\t\tif ( even ) {\n\t\t\t\t\t\t\tconst labelY = posY + fontSize * ( posY == channelTop ? .8 : .35 );\n\t\t\t\t\t\t\tif ( mirrorMode != -1 )\n\t\t\t\t\t\t\t\tctx.fillText( db, scaleWidth * .85, labelY );\n\t\t\t\t\t\t\tif ( mirrorMode != 1 )\n\t\t\t\t\t\t\t\tctx.fillText( db, canvas.width - scaleWidth * .1, labelY );\n\t\t\t\t\t\t\tctx.strokeStyle = '#888';\n\t\t\t\t\t\t\tctx.setLineDash([2,4]);\n\t\t\t\t\t\t\tctx.lineDashOffset = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tctx.strokeStyle = '#555';\n\t\t\t\t\t\t\tctx.setLineDash([2,8]);\n\t\t\t\t\t\t\tctx.lineDashOffset = 1;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.moveTo( initialX + scaleWidth * even * ( mirrorMode != -1 ), ~~posY + .5 ); // for sharp 1px line (https://stackoverflow.com/a/13879402/2370385)\n\t\t\t\t\t\tctx.lineTo( finalX - scaleWidth * even * ( mirrorMode != 1 ), ~~posY + .5 );\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\t\t\t\t\t// restore line properties\n\t\t\t\t\tctx.setLineDash([]);\n\t\t\t\t\tctx.lineDashOffset = 0;\n\t\t\t\t}\n\n\t\t\t\t// set line width and dash for LEDs effect\n\t\t\t\tif ( isLedDisplay ) {\n\t\t\t\t\tctx.setLineDash( [ ledHeight, ledSpaceV ] );\n\t\t\t\t\tctx.lineWidth = width;\n\t\t\t\t}\n\t\t\t\telse // for outline effect ensure linewidth is not greater than half the bar width\n\t\t\t\t\tctx.lineWidth = isOutline ? Math.min( lineWidth, width / 2 ) : lineWidth;\n\n\t\t\t\t// set selected gradient for fill and stroke\n\t\t\t\tctx.fillStyle = ctx.strokeStyle = this._canvasGradient;\n\t\t\t} // if ( useCanvas )\n\n\t\t\t// get a new array of data from the FFT\n\t\t\tconst fftData = this._fftData[ channel ];\n\t\t\tthis._analyzer[ channel ].getByteFrequencyData( fftData );\n\n\t\t\t// helper function for FFT data interpolation\n\t\t\tconst interpolate = ( bin, ratio ) => fftData[ bin ] + ( fftData[ bin + 1 ] - fftData[ bin ] ) * ratio;\n\n\t\t\t// start drawing path (for mode 10)\n\t\t\tctx.beginPath();\n\n\t\t\t// store line graph points to create mirror effect in radial mode\n\t\t\tlet points = [];\n\n\t\t\t// draw bars / lines\n\n\t\t\tfor ( let i = 0; i < nBars; i++ ) {\n\n\t\t\t\tconst bar = this._bars[ i ],\n\t\t\t\t\t  { binLo, binHi, ratioLo, ratioHi } = bar;\n\n\t\t\t\tlet barHeight = Math.max( interpolate( binLo, ratioLo ), interpolate( binHi, ratioHi ) );\n\n\t\t\t\t// check additional bins (if any) for this bar and keep the highest value\n\t\t\t\tfor ( let j = binLo + 1; j < binHi; j++ ) {\n\t\t\t\t\tif ( fftData[ j ] > barHeight )\n\t\t\t\t\t\tbarHeight = fftData[ j ];\n\t\t\t\t}\n\n\t\t\t\tbarHeight /= 255;\n\t\t\t\tbar.value[ channel ] = barHeight;\n\t\t\t\tcurrentEnergy += barHeight;\n\n\t\t\t\t// update bar peak\n\t\t\t\tif ( bar.peak[ channel ] > 0 ) {\n\t\t\t\t\tbar.hold[ channel ]--;\n\t\t\t\t\t// if hold is negative, it becomes the \"acceleration\" for peak drop\n\t\t\t\t\tif ( bar.hold[ channel ] < 0 )\n\t\t\t\t\t\tbar.peak[ channel ] += bar.hold[ channel ] / maxBarHeight;\n\t\t\t\t}\n\n\t\t\t\t// check if it's a new peak for this bar\n\t\t\t\tif ( barHeight >= bar.peak[ channel ] ) {\n\t\t\t\t\tbar.peak[ channel ] = barHeight;\n\t\t\t\t\tbar.hold[ channel ] = 30; // set peak hold time to 30 frames (0.5s)\n\t\t\t\t}\n\n\t\t\t\t// if not using the canvas, move earlier to the next bar\n\t\t\t\tif ( ! useCanvas )\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// set opacity for bar effects\n\t\t\t\tif ( isLumiBars || isAlphaBars )\n\t\t\t\t\tctx.globalAlpha = barHeight;\n\t\t\t\telse if ( isOutline )\n\t\t\t\t\tctx.globalAlpha = this.fillAlpha;\n\n\t\t\t\t// normalize barHeight\n\t\t\t\tif ( isLedDisplay ) {\n\t\t\t\t\tbarHeight = ledPosY( barHeight );\n\t\t\t\t\tif ( barHeight < 0 )\n\t\t\t\t\t\tbarHeight = 0; // prevent showing leds below 0 when overlay and reflex are active\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tbarHeight = barHeight * maxBarHeight | 0;\n\n\t\t\t\t// invert bar for radial channel 1\n\t\t\t\tif ( isRadial && channel == 1 )\n\t\t\t\t\tbarHeight *= -1;\n\n\t\t\t\t// bar width may need small adjustments for some bars, when barSpace == 0\n\t\t\t\tlet adjWidth = width,\n\t\t\t\t\tposX     = bar.posX;\n\n\t\t\t\t// Draw current bar or line segment\n\n\t\t\t\tif ( mode == 10 ) {\n\t\t\t\t\t// compute the average between the initial bar (i==0) and the next one\n\t\t\t\t\t// used to smooth the curve when the initial posX is off the screen, in mirror and radial modes\n\t\t\t\t\tconst nextBarAvg = i ? 0 : ( fftData[ this._bars[1].binLo ] / 255 * maxBarHeight * ( ! isRadial || ! channel || - 1 ) + barHeight ) / 2;\n\n\t\t\t\t\tif ( isRadial ) {\n\t\t\t\t\t\tif ( i == 0 )\n\t\t\t\t\t\t\tctx.lineTo( ...radialXY( 0, ( posX < 0 ? nextBarAvg : barHeight ), 1 ) );\n\t\t\t\t\t\t// draw line to the current point, avoiding overlapping wrap-around frequencies\n\t\t\t\t\t\tif ( posX >= 0 ) {\n\t\t\t\t\t\t\tconst point = [ posX, barHeight ];\n\t\t\t\t\t\t\tctx.lineTo( ...radialXY( ...point, 1 ) );\n\t\t\t\t\t\t\tpoints.push( point );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse { // Linear\n\t\t\t\t\t\tif ( i == 0 ) {\n\t\t\t\t\t\t\t// start the line off-screen using the previous FFT bin value as the initial amplitude\n\t\t\t\t\t\t\tif ( mirrorMode != -1 ) {\n\t\t\t\t\t\t\t\tconst prevFFTData = binLo ? fftData[ binLo - 1 ] / 255 * maxBarHeight : barHeight; // use previous FFT bin value, when available\n\t\t\t\t\t\t\t\tctx.moveTo( initialX - lineWidth, analyzerBottom - prevFFTData );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tctx.moveTo( initialX, analyzerBottom - ( posX < initialX ? nextBarAvg : barHeight ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// draw line to the current point\n\t\t\t\t\t\t// avoid X values lower than the origin when mirroring left, otherwise draw them for best graph accuracy\n\t\t\t\t\t\tif ( mirrorMode != -1 || posX >= initialX )\n\t\t\t\t\t\t\tctx.lineTo( posX, analyzerBottom - barHeight );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( mode > 0 ) {\n\t\t\t\t\t\tif ( isLedDisplay )\n\t\t\t\t\t\t\tposX += Math.max( ledSpaceH / 2, this._barSpacePx / 2 );\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif ( this._barSpace == 0 ) {\n\t\t\t\t\t\t\t\tposX |= 0;\n\t\t\t\t\t\t\t\tif ( i > 0 && posX > this._bars[ i - 1 ].posX + width ) {\n\t\t\t\t\t\t\t\t\tposX--;\n\t\t\t\t\t\t\t\t\tadjWidth++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tposX += this._barSpacePx / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( isLedDisplay ) {\n\t\t\t\t\t\tconst x = posX + width / 2;\n\t\t\t\t\t\t// draw \"unlit\" leds\n\t\t\t\t\t\tif ( this.showBgColor && ! this.overlay ) {\n\t\t\t\t\t\t\tconst alpha = ctx.globalAlpha;\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\tctx.moveTo( x, channelTop );\n\t\t\t\t\t\t\tctx.lineTo( x, analyzerBottom );\n\t\t\t\t\t\t\tctx.strokeStyle = '#7f7f7f22';\n\t\t\t\t\t\t\tctx.globalAlpha = 1;\n\t\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t\t\t// restore properties\n\t\t\t\t\t\t\tctx.strokeStyle = ctx.fillStyle;\n\t\t\t\t\t\t\tctx.globalAlpha = alpha;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.moveTo( x, isLumiBars ? channelTop : analyzerBottom );\n\t\t\t\t\t\tctx.lineTo( x, isLumiBars ? channelBottom : analyzerBottom - barHeight );\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\t\t\t\t\telse if ( posX >= initialX ) {\n\t\t\t\t\t\tif ( isRadial )\n\t\t\t\t\t\t\tradialPoly( posX, 0, adjWidth, barHeight, isOutline );\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tconst x = posX,\n\t\t\t\t\t\t\t\t  y = isLumiBars ? channelTop : analyzerBottom,\n\t\t\t\t\t\t\t\t  w = adjWidth,\n\t\t\t\t\t\t\t\t  h = isLumiBars ? channelBottom : -barHeight;\n\n\t\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\t\tctx.moveTo( x, y );\n\t\t\t\t\t\t\tctx.lineTo( x, y + h );\n\t\t\t\t\t\t\tctx.lineTo( x + w, y + h );\n\t\t\t\t\t\t\tctx.lineTo( x + w, y );\n\n\t\t\t\t\t\t\tstrokeIf( isOutline );\n\t\t\t\t\t\t\tctx.fill();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Draw peak\n\t\t\t\tconst peak = bar.peak[ channel ];\n\t\t\t\tif ( peak > 0 && this.showPeaks && ! isLumiBars && posX >= initialX && posX < finalX ) {\n\t\t\t\t\t// choose the best opacity for the peaks\n\t\t\t\t\tif ( isOutline && lineWidth > 0 )\n\t\t\t\t\t\tctx.globalAlpha = 1;\n\t\t\t\t\telse if ( isAlphaBars )\n\t\t\t\t\t\tctx.globalAlpha = peak;\n\n\t\t\t\t\t// render peak according to current mode / effect\n\t\t\t\t\tif ( isLedDisplay )\n\t\t\t\t\t\tctx.fillRect( posX,\tanalyzerBottom - ledPosY( peak ), width, ledHeight );\n\t\t\t\t\telse if ( ! isRadial )\n\t\t\t\t\t\tctx.fillRect( posX, analyzerBottom - peak * maxBarHeight, adjWidth, 2 );\n\t\t\t\t\telse if ( mode != 10 ) // radial - no peaks for mode 10\n\t\t\t\t\t\tradialPoly( posX, peak * maxBarHeight * ( ! channel || -1 ), adjWidth, -2 );\n\t\t\t\t}\n\n\t\t\t} // for ( let i = 0; i < nBars; i++ )\n\n\t\t\t// if not using the canvas, move earlier to the next channel\n\t\t\tif ( ! useCanvas )\n\t\t\t\tcontinue;\n\n\t\t\t// restore global alpha\n\t\t\tctx.globalAlpha = 1;\n\n\t\t\t// Fill/stroke drawing path for mode 10\n\t\t\tif ( mode == 10 ) {\n\t\t\t\tif ( isRadial ) {\n\t\t\t\t\tif ( mirrorMode ) {\n\t\t\t\t\t\tlet p;\n\t\t\t\t\t\twhile ( p = points.pop() )\n\t\t\t\t\t\t\tctx.lineTo( ...radialXY( ...p, -1 ) );\n\t\t\t\t\t}\n\t\t\t\t\tctx.closePath();\n\t\t\t\t}\n\n\t\t\t\tif ( lineWidth > 0 )\n\t\t\t\t\tctx.stroke();\n\n\t\t\t\tif ( this.fillAlpha > 0 ) {\n\t\t\t\t\tif ( isRadial ) {\n\t\t\t\t\t\t// exclude the center circle from the fill area\n\t\t\t\t\t\tctx.moveTo( centerX + radius, centerY );\n\t\t\t\t\t\tctx.arc( centerX, centerY, radius, 0, TAU, true );\n\t\t\t\t\t}\n\t\t\t\t\telse { // close the fill area\n\t\t\t\t\t\tctx.lineTo( finalX, analyzerBottom );\n\t\t\t\t\t\tctx.lineTo( initialX, analyzerBottom );\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.globalAlpha = this.fillAlpha;\n\t\t\t\t\tctx.fill();\n\t\t\t\t\tctx.globalAlpha = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Reflex effect\n\t\t\tif ( this._reflexRatio > 0 && ! isLumiBars ) {\n\t\t\t\tlet posY, height;\n\t\t\t\tif ( this.reflexFit || isStereo ) { // always fit reflex in stereo mode\n\t\t\t\t\tposY   = isStereo && channel == 0 ? channelHeight + channelGap : 0;\n\t\t\t\t\theight = channelHeight - analyzerHeight;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tposY   = canvas.height - analyzerHeight * 2;\n\t\t\t\t\theight = analyzerHeight;\n\t\t\t\t}\n\n\t\t\t\t// set alpha and brightness for the reflection\n\t\t\t\tctx.globalAlpha = this.reflexAlpha;\n\t\t\t\tif ( this.reflexBright != 1 )\n\t\t\t\t\tctx.filter = `brightness(${this.reflexBright})`;\n\n\t\t\t\t// create the reflection\n\t\t\t\tctx.setTransform( 1, 0, 0, -1, 0, canvas.height );\n\t\t\t\tctx.drawImage( canvas, 0, channelTop, canvas.width, analyzerHeight, 0, posY, canvas.width, height );\n\n\t\t\t\t// reset changed properties\n\t\t\t\tctx.setTransform( 1, 0, 0, 1, 0, 0 );\n\t\t\t\tctx.filter = 'none';\n\t\t\t\tctx.globalAlpha = 1;\n\t\t\t}\n\n\t\t} // for ( let channel = 0; channel < isStereo + 1; channel++ ) {\n\n\t\t// Update energy\n\t\tenergy.val = currentEnergy / ( nBars << isStereo );\n\t\tif ( energy.val >= energy.peak ) {\n\t\t\tenergy.peak = energy.val;\n\t\t\tenergy.hold = 30;\n\t\t}\n\t\telse {\n\t\t\tif ( energy.hold > 0 )\n\t\t\t\tenergy.hold--;\n\t\t\telse if ( energy.peak > 0 )\n\t\t\t\tenergy.peak *= ( 30 + energy.hold-- ) / 30; // decay (drops to zero in 30 frames)\n\t\t}\n\n\t\tif ( useCanvas ) {\n\t\t\t// Mirror effect\n\t\t\tif ( mirrorMode && ! isRadial ) {\n\t\t\t\tctx.setTransform( -1, 0, 0, 1, canvas.width - initialX, 0 );\n\t\t\t\tctx.drawImage( canvas, initialX, 0, centerX, canvas.height, 0, 0, centerX, canvas.height );\n\t\t\t\tctx.setTransform( 1, 0, 0, 1, 0, 0 );\n\t\t\t}\n\n\t\t\t// restore solid lines\n\t\t\tctx.setLineDash([]);\n\n\t\t\t// draw frequency scale (X-axis)\n\t\t\tif ( this.showScaleX ) {\n\t\t\t\tif ( isRadial ) {\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.translate( centerX, centerY );\n\t\t\t\t\tif ( this._spinSpeed )\n\t\t\t\t\t\tctx.rotate( this._spinAngle + HALF_PI );\n\t\t\t\t\tctx.drawImage( canvasR, -canvasR.width >> 1, -canvasR.width >> 1 );\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tctx.drawImage( canvasX, 0, canvas.height - canvasX.height );\n\t\t\t}\n\t\t}\n\n\t\t// calculate and update current frame rate\n\n\t\tthis._frame++;\n\t\tconst elapsed = timestamp - this._time;\n\n\t\tif ( elapsed >= 1000 ) {\n\t\t\tthis._fps = this._frame / ( elapsed / 1000 );\n\t\t\tthis._frame = 0;\n\t\t\tthis._time = timestamp;\n\t\t}\n\t\tif ( this.showFPS ) {\n\t\t\tconst size = canvasX.height;\n\t\t\tctx.font = `bold ${size}px sans-serif`;\n\t\t\tctx.fillStyle = '#0f0';\n\t\t\tctx.textAlign = 'right';\n\t\t\tctx.fillText( Math.round( this._fps ), canvas.width - size, size * 2 );\n\t\t}\n\n\t\t// call callback function, if defined\n\t\tif ( this.onCanvasDraw ) {\n\t\t\tctx.save();\n\t\t\tctx.fillStyle = ctx.strokeStyle = this._canvasGradient;\n\t\t\tthis.onCanvasDraw( this );\n\t\t\tctx.restore();\n\t\t}\n\n\t\t// schedule next canvas update\n\t\tthis._runId = requestAnimationFrame( timestamp => this._draw( timestamp ) );\n\t}\n\n\t/**\n\t * Return the FFT data bin (array index) which represents a given frequency\n\t */\n\t_freqToBin( freq, rounding = 'round' ) {\n\t\tconst max = this._analyzer[0].frequencyBinCount - 1,\n\t\t\t  bin = Math[ rounding ]( freq * this.fftSize / this.audioCtx.sampleRate );\n\n\t\treturn bin < max ? bin : max;\n\t}\n\n\t/**\n\t * Generate currently selected gradient\n\t */\n\t_makeGrad() {\n\n\t\tif ( ! this._ready )\n\t\t\treturn;\n\n\t\tconst ctx            = this._canvasCtx,\n\t\t\t  canvas         = ctx.canvas,\n\t\t\t  isLumiBars     = this._isLumiBars,\n\t\t\t  gradientHeight = isLumiBars ? canvas.height : canvas.height * ( 1 - this._reflexRatio * ! this._stereo ) | 0,\n\t\t\t  \t\t\t\t\t// for stereo we keep the full canvas height and handle the reflex areas while generating the color stops\n\t\t\t  analyzerRatio  = 1 - this._reflexRatio,\n\t\t\t  initialX       = this._initialX;\n\n\t\t// for radial mode\n\t\tconst centerX   = canvas.width >> 1,\n\t\t\t  centerY   = canvas.height >> 1,\n\t\t\t  maxRadius = Math.min( centerX, centerY ),\n\t\t\t  radius    = this._radius;\n\n\t\tconst currGradient = this._gradients[ this._gradient ],\n\t\t\t  colorStops   = currGradient.colorStops,\n\t\t\t  isHorizontal = currGradient.dir == 'h';\n\n\t\tlet grad;\n\n\t\tif ( this._radial )\n\t\t\tgrad = ctx.createRadialGradient( centerX, centerY, maxRadius, centerX, centerY, radius - ( maxRadius - radius ) * this._stereo );\n\t\telse\n\t\t\tgrad = ctx.createLinearGradient( ...( isHorizontal ? [ initialX, 0, initialX + this._analyzerWidth, 0 ] : [ 0, 0, 0, gradientHeight ] ) );\n\n\t\tif ( colorStops ) {\n\t\t\tconst dual = this._stereo && ! this._splitGradient && ! isHorizontal;\n\n\t\t\t// helper function\n\t\t\tconst addColorStop = ( offset, colorInfo ) => grad.addColorStop( offset, colorInfo.color || colorInfo );\n\n\t\t\tfor ( let channel = 0; channel < 1 + dual; channel++ ) {\n\t\t\t\tcolorStops.forEach( ( colorInfo, index ) => {\n\n\t\t\t\t\tconst maxIndex = colorStops.length - 1;\n\n\t\t\t\t\tlet offset = colorInfo.pos !== undefined ? colorInfo.pos : index / maxIndex;\n\n\t\t\t\t\t// in dual mode (not split), use half the original offset for each channel\n\t\t\t\t\tif ( dual )\n\t\t\t\t\t\toffset /= 2;\n\n\t\t\t\t\t// constrain the offset within the useful analyzer areas (avoid reflex areas)\n\t\t\t\t\tif ( this._stereo && ! isLumiBars && ! this._radial && ! isHorizontal ) {\n\t\t\t\t\t\toffset *= analyzerRatio;\n\t\t\t\t\t\t// skip the first reflex area in split mode\n\t\t\t\t\t\tif ( ! dual && offset > .5 * analyzerRatio )\n\t\t\t\t\t\t\toffset += .5 * this._reflexRatio;\n\t\t\t\t\t}\n\n\t\t\t\t\t// only for split mode\n\t\t\t\t\tif ( channel == 1 ) {\n\t\t\t\t\t\t// add colors in reverse order if radial or lumi are active\n\t\t\t\t\t\tif ( this._radial || isLumiBars ) {\n\t\t\t\t\t\t\tconst revIndex = maxIndex - index;\n\t\t\t\t\t\t\tcolorInfo = colorStops[ revIndex ];\n\t\t\t\t\t\t\toffset = 1 - ( colorInfo.pos !== undefined ? colorInfo.pos : revIndex / maxIndex ) / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// if the first offset is not 0, create an additional color stop to prevent bleeding from the first channel\n\t\t\t\t\t\t\tif ( index == 0 && offset > 0 )\n\t\t\t\t\t\t\t\taddColorStop( .5, colorInfo );\n\t\t\t\t\t\t\t// bump the offset to the second half of the gradient\n\t\t\t\t\t\t\toffset += .5;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// add gradient color stop\n\t\t\t\t\taddColorStop( offset, colorInfo );\n\n\t\t\t\t\t// create additional color stop at the end of first channel to prevent bleeding\n\t\t\t\t\tif ( this._stereo && index == maxIndex && offset < .5 )\n\t\t\t\t\t\taddColorStop( .5, colorInfo );\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tthis._canvasGradient = grad;\n\t}\n\n\t/**\n\t * Internal function to change canvas dimensions on demand\n\t */\n\t_setCanvas( reason ) {\n\t\t// if initialization is not finished, quit\n\t\tif ( ! this._ready )\n\t\t\treturn;\n\n\t\tconst ctx        = this._canvasCtx,\n\t\t\t  canvas     = ctx.canvas,\n\t\t\t  canvasX    = this._scaleX.canvas,\n\t\t\t  pixelRatio = window.devicePixelRatio / ( this._loRes + 1 );\n\n\t\tlet screenWidth  = window.screen.width  * pixelRatio,\n\t\t\tscreenHeight = window.screen.height * pixelRatio;\n\n\t\t// Fix for iOS Safari - swap width and height when in landscape\n\t\tif ( Math.abs( window.orientation ) == 90 && screenWidth < screenHeight )\n\t\t\t[ screenWidth, screenHeight ] = [ screenHeight, screenWidth ];\n\n\t\tconst isFullscreen = this.isFullscreen,\n\t\t\t  isCanvasFs   = isFullscreen && this._fsEl == canvas,\n\t\t\t  newWidth     = isCanvasFs ? screenWidth  : ( this._width  || this._container.clientWidth  || this._defaultWidth  ) * pixelRatio | 0,\n\t\t\t  newHeight    = isCanvasFs ? screenHeight : ( this._height || this._container.clientHeight || this._defaultHeight ) * pixelRatio | 0;\n\n\t\t// set/update object properties\n\t\tthis._pixelRatio = pixelRatio;\n\t\tthis._fsWidth    = screenWidth;\n\t\tthis._fsHeight   = screenHeight;\n\n\t\t// if canvas dimensions haven't changed, quit\n\t\tif ( canvas.width == newWidth && canvas.height == newHeight )\n\t\t\treturn;\n\n\t\t// apply new dimensions\n\t\tcanvas.width  = newWidth;\n\t\tcanvas.height = newHeight;\n\n\t\t// update internal variables\n\t\tthis._calcAux();\n\n\t\t// if not in overlay mode, paint the canvas black\n\t\tif ( ! this.overlay ) {\n\t\t\tctx.fillStyle = '#000';\n\t\t\tctx.fillRect( 0, 0, newWidth, newHeight );\n\t\t}\n\n\t\t// set lineJoin property for area fill mode (this is reset whenever the canvas size changes)\n\t\tctx.lineJoin = 'bevel';\n\n\t\t// update dimensions of the scale canvas\n\t\tcanvasX.width = newWidth;\n\t\tcanvasX.height = Math.max( 20 * pixelRatio, Math.min( newWidth, newHeight ) / 27 | 0 );\n\n\t\t// (re)generate gradient\n\t\tthis._makeGrad();\n\n\t\t// calculate bar positions and led options\n\t\tthis._calcBars();\n\n\t\t// detect fullscreen changes (for Safari)\n\t\tif ( this._fsStatus !== undefined && this._fsStatus !== isFullscreen )\n\t\t\treason = 'fschange';\n\t\tthis._fsStatus = isFullscreen;\n\n\t\t// call the callback function, if defined\n\t\tif ( this.onCanvasResize )\n\t\t\tthis.onCanvasResize( reason, this );\n\t}\n\n\t/**\n\t * Set object properties\n\t */\n\t_setProps( options, useDefaults ) {\n\n\t\t// settings defaults\n\t\tconst defaults = {\n\t\t\talphaBars    : false,\n\t\t\tbarSpace     : 0.1,\n\t\t\tbgAlpha      : 0.7,\n\t\t\tfftSize      : 8192,\n\t\t\tfillAlpha    : 1,\n\t\t\tgradient     : 'classic',\n\t\t\tledBars      : false,\n\t\t\tlineWidth    : 0,\n\t\t\tloRes        : false,\n\t\t\tlumiBars     : false,\n\t\t\tmaxDecibels  : -25,\n\t\t\tmaxFreq      : 22000,\n\t\t\tminDecibels  : -85,\n\t\t\tminFreq      : 20,\n\t\t\tmirror       : 0,\n\t\t\tmode         : 0,\n\t\t\toutlineBars  : false,\n\t\t\toverlay      : false,\n\t\t\tradial\t\t : false,\n\t\t\treflexAlpha  : 0.15,\n\t\t\treflexBright : 1,\n\t\t\treflexFit    : true,\n\t\t\treflexRatio  : 0,\n\t\t\tshowBgColor  : true,\n\t\t\tshowFPS      : false,\n\t\t\tshowPeaks    : true,\n\t\t\tshowScaleX   : true,\n\t\t\tshowScaleY   : false,\n\t\t\tsmoothing    : 0.5,\n\t\t\tspinSpeed    : 0,\n\t\t\tsplitGradient: false,\n\t\t\tstart        : true,\n\t\t\tstereo       : false,\n\t\t\tuseCanvas    : true,\n\t\t\tvolume       : 1,\n\t\t};\n\n\t\t// callback functions properties\n\t\tconst callbacks = [ 'onCanvasDraw', 'onCanvasResize' ];\n\n\t\t// build an array of valid properties; `start` is not an actual property and is handled after setting everything else\n\t\tconst validProps = Object.keys( defaults ).filter( e => e != 'start' ).concat( callbacks, ['height', 'width'] );\n\n\t\t// handle deprecated `showLeds` property\n\t\tif ( options && options.showLeds !== undefined && options.ledBars === undefined )\n\t\t\toptions.ledBars = options.showLeds;\n\n\t\tif ( useDefaults || options === undefined )\n\t\t\toptions = { ...defaults, ...options }; // merge options with defaults\n\n\t\tfor ( const prop of Object.keys( options ) ) {\n\t\t\tif ( callbacks.includes( prop ) && typeof options[ prop ] !== 'function' ) // check invalid callback\n\t\t\t\tthis[ prop ] = undefined;\n\t\t\telse if ( validProps.includes( prop ) ) // set only valid properties\n\t\t\t\tthis[ prop ] = options[ prop ];\n\t\t}\n\n\t\tif ( options.start !== undefined )\n\t\t\tthis.toggleAnalyzer( options.start );\n\t}\n\n}\n\n/* Custom error class */\n\nclass AudioMotionError extends Error {\n\tconstructor( code, message ) {\n\t\tsuper( message );\n\t\tthis.name = 'AudioMotionError';\n\t\tthis.code = code;\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYXVkaW9tb3Rpb24tYW5hbHl6ZXIvc3JjL2F1ZGlvTW90aW9uLWFuYWx5emVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRXBCOztBQUVmO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUSxzREFBc0Q7QUFDekUsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBLHNDQUFzQzs7QUFFdEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sd0NBQXdDO0FBQy9DO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsTUFBTTs7QUFFbkY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLE1BQU07QUFDMUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnRUFBZ0U7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU8sZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYSw0REFBNEQ7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EscUNBQXFDLDBDQUEwQyxTQUFTLDBDQUEwQztBQUNsSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWMsb0RBQW9EO0FBQy9FLGFBQWEsT0FBTztBQUNwQixjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0MsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhFQUE4RSwwQ0FBMEM7QUFDeEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBLCtFQUErRTtBQUMvRSw2RkFBNkYsMkZBQTJGOztBQUV4TDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx5QkFBeUIsYUFBYTtBQUN0Qyx3QkFBd0IsV0FBVzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsbUJBQW1CO0FBQzlDO0FBQ0E7O0FBRUE7O0FBRUEsc0RBQXNEOztBQUV0RCx3QkFBd0IsOEJBQThCO0FBQ3RELFVBQVUsMkNBQTJDO0FBQ3JELE9BQU8sMkNBQTJDLHNDQUFzQzs7QUFFeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0EsbUZBQW1GOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTs7QUFFdEU7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QyxvQkFBb0Isa0JBQWtCO0FBQ3RDOztBQUVBO0FBQ0Esd0NBQXdDLGFBQWE7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQixvQkFBb0I7QUFDOUM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLDJCQUEyQjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NwYXJrLy4vbm9kZV9tb2R1bGVzL2F1ZGlvbW90aW9uLWFuYWx5emVyL3NyYy9hdWRpb01vdGlvbi1hbmFseXplci5qcz9lYzc0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiFcbiAqIGF1ZGlvTW90aW9uLWFuYWx5emVyXG4gKiBIaWdoLXJlc29sdXRpb24gcmVhbC10aW1lIGdyYXBoaWMgYXVkaW8gc3BlY3RydW0gYW5hbHl6ZXIgSlMgbW9kdWxlXG4gKlxuICogQHZlcnNpb24gMy42LjFcbiAqIEBhdXRob3IgIEhlbnJpcXVlIEF2aWxhIFZpYW5uYSA8aHZpYW5uYUBnbWFpbC5jb20+IDxodHRwczovL2hlbnJpcXVldmlhbm5hLmNvbT5cbiAqIEBsaWNlbnNlIEFHUEwtMy4wLW9yLWxhdGVyXG4gKi9cblxuY29uc3QgVkVSU0lPTiA9ICczLjYuMSc7XG5cbi8vIGludGVybmFsIGNvbnN0YW50c1xuY29uc3QgVEFVICAgICA9IDIgKiBNYXRoLlBJLFxuXHQgIEhBTEZfUEkgPSBNYXRoLlBJIC8gMixcblx0ICBSUE0gICAgID0gVEFVIC8gMzYwMCwgICAgICAgICAgIC8vIGFuZ2xlIGluY3JlbWVudCBwZXIgZnJhbWUgZm9yIG9uZSByZXZvbHV0aW9uIHBlciBtaW51dGUgQDYwZnBzXG5cdCAgUk9PVDI0ICA9IDIgKiogKCAxIC8gMjQgKSwgICAgICAvLyAyNHRoIHJvb3Qgb2YgMlxuXHQgIEMwICAgICAgPSA0NDAgKiBST09UMjQgKiogLTExNDsgLy8gfjE2LjM1IEh6XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF1ZGlvTW90aW9uQW5hbHl6ZXIge1xuXG4vKipcbiAqIENPTlNUUlVDVE9SXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtjb250YWluZXJdIERPTSBlbGVtZW50IHdoZXJlIHRvIGluc2VydCB0aGUgYW5hbHl6ZXI7IGlmIHVuZGVmaW5lZCwgdXNlcyB0aGUgZG9jdW1lbnQgYm9keVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybnMge29iamVjdH0gQXVkaW9Nb3Rpb25BbmFseXplciBvYmplY3RcbiAqL1xuXHRjb25zdHJ1Y3RvciggY29udGFpbmVyLCBvcHRpb25zID0ge30gKSB7XG5cblx0XHR0aGlzLl9yZWFkeSA9IGZhbHNlO1xuXG5cdFx0Ly8gR3JhZGllbnQgZGVmaW5pdGlvbnNcblxuXHRcdHRoaXMuX2dyYWRpZW50cyA9IHtcblx0XHRcdGNsYXNzaWM6IHtcblx0XHRcdFx0YmdDb2xvcjogJyMxMTEnLFxuXHRcdFx0XHRjb2xvclN0b3BzOiBbXG5cdFx0XHRcdFx0J2hzbCggMCwgMTAwJSwgNTAlICknLFxuXHRcdFx0XHRcdHsgcG9zOiAuNiwgY29sb3I6ICdoc2woIDYwLCAxMDAlLCA1MCUgKScgfSxcblx0XHRcdFx0XHQnaHNsKCAxMjAsIDEwMCUsIDUwJSApJ1xuXHRcdFx0XHRdXG5cdFx0XHR9LFxuXHRcdFx0cHJpc206ICAge1xuXHRcdFx0XHRiZ0NvbG9yOiAnIzExMScsXG5cdFx0XHRcdGNvbG9yU3RvcHM6IFtcblx0XHRcdFx0XHQnaHNsKCAwLCAxMDAlLCA1MCUgKScsXG5cdFx0XHRcdFx0J2hzbCggNjAsIDEwMCUsIDUwJSApJyxcblx0XHRcdFx0XHQnaHNsKCAxMjAsIDEwMCUsIDUwJSApJyxcblx0XHRcdFx0XHQnaHNsKCAxODAsIDEwMCUsIDUwJSApJyxcblx0XHRcdFx0XHQnaHNsKCAyNDAsIDEwMCUsIDUwJSApJ1xuXHRcdFx0XHRdXG5cdFx0XHR9LFxuXHRcdFx0cmFpbmJvdzoge1xuXHRcdFx0XHRiZ0NvbG9yOiAnIzExMScsXG5cdFx0XHRcdGRpcjogJ2gnLFxuXHRcdFx0XHRjb2xvclN0b3BzOiBbXG5cdFx0XHRcdFx0J2hzbCggMCwgMTAwJSwgNTAlICknLFxuXHRcdFx0XHRcdCdoc2woIDYwLCAxMDAlLCA1MCUgKScsXG5cdFx0XHRcdFx0J2hzbCggMTIwLCAxMDAlLCA1MCUgKScsXG5cdFx0XHRcdFx0J2hzbCggMTgwLCAxMDAlLCA0NyUgKScsXG5cdFx0XHRcdFx0J2hzbCggMjQwLCAxMDAlLCA1OCUgKScsXG5cdFx0XHRcdFx0J2hzbCggMzAwLCAxMDAlLCA1MCUgKScsXG5cdFx0XHRcdFx0J2hzbCggMzYwLCAxMDAlLCA1MCUgKSdcblx0XHRcdFx0XVxuXHRcdFx0fSxcblx0XHR9O1xuXG5cdFx0Ly8gU2V0IGNvbnRhaW5lclxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIGhhdmUgbWluaW1hbCB3aWR0aCBhbmQgaGVpZ2h0IGRpbWVuc2lvbnMgaW4gY2FzZSBvZiBhbiBpbmxpbmUgY29udGFpbmVyXG5cdFx0dGhpcy5fZGVmYXVsdFdpZHRoICA9IHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCAgfHwgNjQwO1xuXHRcdHRoaXMuX2RlZmF1bHRIZWlnaHQgPSB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0IHx8IDI3MDtcblxuXHRcdC8vIFVzZSBhdWRpbyBjb250ZXh0IHByb3ZpZGVkIGJ5IHVzZXIsIG9yIGNyZWF0ZSBhIG5ldyBvbmVcblxuXHRcdGxldCBhdWRpb0N0eDtcblxuXHRcdGlmICggb3B0aW9ucy5zb3VyY2UgJiYgKCBhdWRpb0N0eCA9IG9wdGlvbnMuc291cmNlLmNvbnRleHQgKSApIHtcblx0XHRcdC8vIGdldCBhdWRpb0NvbnRleHQgZnJvbSBwcm92aWRlZCBzb3VyY2UgYXVkaW9Ob2RlXG5cdFx0fVxuXHRcdGVsc2UgaWYgKCBhdWRpb0N0eCA9IG9wdGlvbnMuYXVkaW9DdHggKSB7XG5cdFx0XHQvLyB1c2UgYXVkaW9Db250ZXh0IHByb3ZpZGVkIGJ5IHVzZXJcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRhdWRpb0N0eCA9IG5ldyAoIHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCApKCk7XG5cdFx0XHR9XG5cdFx0XHRjYXRjaCggZXJyICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgQXVkaW9Nb3Rpb25FcnJvciggJ0VSUl9BVURJT19DT05URVhUX0ZBSUwnLCAnQ291bGQgbm90IGNyZWF0ZSBhdWRpbyBjb250ZXh0LiBXZWIgQXVkaW8gQVBJIG5vdCBzdXBwb3J0ZWQ/JyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIG1ha2Ugc3VyZSBhdWRpb0NvbnRleHQgaXMgdmFsaWRcblx0XHRpZiAoICEgYXVkaW9DdHguY3JlYXRlR2FpbiApXG5cdFx0XHR0aHJvdyBuZXcgQXVkaW9Nb3Rpb25FcnJvciggJ0VSUl9JTlZBTElEX0FVRElPX0NPTlRFWFQnLCAnUHJvdmlkZWQgYXVkaW8gY29udGV4dCBpcyBub3QgdmFsaWQnICk7XG5cblx0XHQvKlxuXHRcdFx0Q29ubmVjdGlvbiByb3V0aW5nOlxuXHRcdFx0PT09PT09PT09PT09PT09PT09PVxuXG5cdFx0XHRmb3IgU1RFUkVPOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0+ICBhbmFseXplclswXSAgLS0tK1xuXHRcdCAgICBcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgIHxcblx0XHRcdChzb3VyY2UpIC0tLT4gIGlucHV0ICAtLS0+ICBzcGxpdHRlciAgLS0tKyAgICAgICAgICAgICAgICAgICAgICArLS0tPiAgbWVyZ2VyICAtLS0+ICBvdXRwdXQgIC0tLT4gKGRlc3RpbmF0aW9uKVxuXHRcdCAgICBcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgIHxcblx0XHQgICAgICAgIFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLT4gIGFuYWx5emVyWzFdICAtLS0rXG5cblx0XHRcdGZvciBNT05POlxuXG5cdFx0XHQoc291cmNlKSAtLS0+ICBpbnB1dCAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0+ICBhbmFseXplclswXSAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tPiAgb3V0cHV0ICAtLS0+IChkZXN0aW5hdGlvbilcblxuXHRcdCovXG5cblx0XHQvLyBjcmVhdGUgdGhlIGFuYWx5emVyIG5vZGVzLCBjaGFubmVsIHNwbGl0dGVyIGFuZCBtZXJnZXIsIGFuZCBnYWluIG5vZGVzIGZvciBpbnB1dC9vdXRwdXQgY29ubmVjdGlvbnNcblx0XHRjb25zdCBhbmFseXplciA9IHRoaXMuX2FuYWx5emVyID0gWyBhdWRpb0N0eC5jcmVhdGVBbmFseXNlcigpLCBhdWRpb0N0eC5jcmVhdGVBbmFseXNlcigpIF07XG5cdFx0Y29uc3Qgc3BsaXR0ZXIgPSB0aGlzLl9zcGxpdHRlciA9IGF1ZGlvQ3R4LmNyZWF0ZUNoYW5uZWxTcGxpdHRlcigyKTtcbiBcdFx0Y29uc3QgbWVyZ2VyICAgPSB0aGlzLl9tZXJnZXIgICA9IGF1ZGlvQ3R4LmNyZWF0ZUNoYW5uZWxNZXJnZXIoMik7XG4gXHRcdHRoaXMuX2lucHV0ICAgID0gYXVkaW9DdHguY3JlYXRlR2FpbigpO1xuIFx0XHR0aGlzLl9vdXRwdXQgICA9IGF1ZGlvQ3R4LmNyZWF0ZUdhaW4oKTtcblxuIFx0XHQvLyBpbml0aWFsaXplIHNvdXJjZXMgYXJyYXkgYW5kIGNvbm5lY3QgYXVkaW8gc291cmNlIGlmIHByb3ZpZGVkIGluIHRoZSBvcHRpb25zXG5cdFx0dGhpcy5fc291cmNlcyA9IFtdO1xuXHRcdGlmICggb3B0aW9ucy5zb3VyY2UgKVxuXHRcdFx0dGhpcy5jb25uZWN0SW5wdXQoIG9wdGlvbnMuc291cmNlICk7XG5cbiBcdFx0Ly8gY29ubmVjdCBzcGxpdHRlciAtPiBhbmFseXplcnNcbiBcdFx0Zm9yICggY29uc3QgaSBvZiBbMCwxXSApXG5cdFx0XHRzcGxpdHRlci5jb25uZWN0KCBhbmFseXplclsgaSBdLCBpICk7XG5cblx0XHQvLyBjb25uZWN0IG1lcmdlciAtPiBvdXRwdXRcblx0XHRtZXJnZXIuY29ubmVjdCggdGhpcy5fb3V0cHV0ICk7XG5cblx0XHQvLyBjb25uZWN0IG91dHB1dCAtPiBkZXN0aW5hdGlvbiAoc3BlYWtlcnMpXG5cdFx0dGhpcy5fb3V0Tm9kZXMgPSBbXTtcblx0XHRpZiAoIG9wdGlvbnMuY29ubmVjdFNwZWFrZXJzICE9PSBmYWxzZSApXG5cdFx0XHR0aGlzLmNvbm5lY3RPdXRwdXQoKTtcblxuXHRcdC8vIGluaXRpYWxpemUgb2JqZWN0IHRvIHNhdmUgZW5lcmd5XG5cdFx0dGhpcy5fZW5lcmd5ID0geyB2YWw6IDAsIHBlYWs6IDAsIGhvbGQ6IDAgfTtcblxuXHRcdC8vIGNyZWF0ZSBhbmFseXplciBjYW52YXNcblx0XHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHRjYW52YXMuc3R5bGUgPSAnbWF4LXdpZHRoOiAxMDAlOyc7XG5cdFx0dGhpcy5fY2FudmFzQ3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cblx0XHQvLyBjcmVhdGUgYXV4aWxpYXJ5IGNhbnZhc2VzIGZvciB0aGUgWC1heGlzIGFuZCByYWRpYWwgc2NhbGUgbGFiZWxzXG5cdFx0Zm9yICggY29uc3QgY3R4IG9mIFsgJ19zY2FsZVgnLCAnX3NjYWxlUicgXSApXG5cdFx0XHR0aGlzWyBjdHggXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG5cblx0XHQvLyBzZXQgZnVsbHNjcmVlbiBlbGVtZW50IChkZWZhdWx0cyB0byBjYW52YXMpXG5cdFx0dGhpcy5fZnNFbCA9IG9wdGlvbnMuZnNFbGVtZW50IHx8IGNhbnZhcztcblxuXHRcdC8vIFVwZGF0ZSBjYW52YXMgc2l6ZSBvbiBjb250YWluZXIgLyB3aW5kb3cgcmVzaXplIGFuZCBmdWxsc2NyZWVuIGV2ZW50c1xuXG5cdFx0Ly8gRnVsbHNjcmVlbiBjaGFuZ2VzIGFyZSBoYW5kbGVkIHF1aXRlIGRpZmZlcmVudGx5IGFjcm9zcyBicm93c2Vyczpcblx0XHQvLyAxLiBDaHJvbWl1bSBicm93c2VycyB3aWxsIHRyaWdnZXIgYSBgcmVzaXplYCBldmVudCBmb2xsb3dlZCBieSBhIGBmdWxsc2NyZWVuY2hhbmdlYFxuXHRcdC8vIDIuIEZpcmVmb3ggdHJpZ2dlcnMgdGhlIGBmdWxsc2NyZWVuY2hhbmdlYCBmaXJzdCBhbmQgdGhlbiB0aGUgYHJlc2l6ZWBcblx0XHQvLyAzLiBDaHJvbWUgb24gQW5kcm9pZCAoVFYpIHdvbid0IHRyaWdnZXIgYSBgcmVzaXplYCBldmVudCwgb25seSBgZnVsbHNjcmVlbmNoYW5nZWBcblx0XHQvLyA0LiBTYWZhcmkgd29uJ3QgdHJpZ2dlciBgZnVsbHNjcmVlbmNoYW5nZWAgZXZlbnRzIGF0IGFsbCwgYW5kIG9uIGlQYWRPUyB0aGUgYHJlc2l6ZWBcblx0XHQvLyAgICBldmVudCBpcyB0cmlnZ2VyZWQgKipvbiB0aGUgd2luZG93Kiogb25seSAobGFzdCB0ZXN0ZWQgb24gaVBhZE9TIDE0KVxuXG5cdFx0Ly8gaGVscGVyIGZ1bmN0aW9uIGZvciByZXNpemUgZXZlbnRzXG5cdFx0Y29uc3Qgb25SZXNpemUgPSAoKSA9PiB7XG5cdFx0XHRpZiAoICEgdGhpcy5fZnNUaW1lb3V0ICkge1xuXHRcdFx0XHQvLyBkZWxheSB0aGUgcmVzaXplIHRvIHByaW9yaXRpemUgYSBwb3NzaWJsZSBmb2xsb3dpbmcgYGZ1bGxzY3JlZW5jaGFuZ2VgIGV2ZW50XG5cdFx0XHRcdHRoaXMuX2ZzVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCAoKSA9PiB7XG5cdFx0XHRcdFx0aWYgKCAhIHRoaXMuX2ZzQ2hhbmdpbmcgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zZXRDYW52YXMoJ3Jlc2l6ZScpO1xuXHRcdFx0XHRcdFx0dGhpcy5fZnNUaW1lb3V0ID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIDYwICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gaWYgYnJvd3NlciBzdXBwb3J0cyBSZXNpemVPYnNlcnZlciwgbGlzdGVuIGZvciByZXNpemUgb24gdGhlIGNvbnRhaW5lclxuXHRcdGlmICggd2luZG93LlJlc2l6ZU9ic2VydmVyICkge1xuXHRcdFx0Y29uc3QgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoIG9uUmVzaXplICk7XG5cdFx0XHRyZXNpemVPYnNlcnZlci5vYnNlcnZlKCB0aGlzLl9jb250YWluZXIgKTtcblx0XHR9XG5cblx0XHQvLyBsaXN0ZW4gZm9yIHJlc2l6ZSBldmVudHMgb24gdGhlIHdpbmRvdyAtIHJlcXVpcmVkIGZvciBmdWxsc2NyZWVuIG9uIGlQYWRPU1xuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAncmVzaXplJywgb25SZXNpemUgKTtcblxuXHRcdC8vIGxpc3RlbiBmb3IgZnVsbHNjcmVlbmNoYW5nZSBldmVudHMgb24gdGhlIGNhbnZhcyAtIG5vdCBhdmFpbGFibGUgb24gU2FmYXJpXG5cdFx0Y2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoICdmdWxsc2NyZWVuY2hhbmdlJywgKCkgPT4ge1xuXHRcdFx0Ly8gc2V0IGZsYWcgdG8gaW5kaWNhdGUgYSBmdWxsc2NyZWVuIGNoYW5nZSBpbiBwcm9ncmVzc1xuXHRcdFx0dGhpcy5fZnNDaGFuZ2luZyA9IHRydWU7XG5cblx0XHRcdC8vIGlmIHRoZXJlIGlzIGEgc2NoZWR1bGVkIHJlc2l6ZSBldmVudCwgY2xlYXIgaXRcblx0XHRcdGlmICggdGhpcy5fZnNUaW1lb3V0IClcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGhpcy5fZnNUaW1lb3V0ICk7XG5cblx0XHRcdC8vIHVwZGF0ZSB0aGUgY2FudmFzXG5cdFx0XHR0aGlzLl9zZXRDYW52YXMoJ2ZzY2hhbmdlJyk7XG5cblx0XHRcdC8vIGRlbGF5IGNsZWFyaW5nIHRoZSBmbGFnIHRvIHByZXZlbnQgYW55IHNob3J0bHkgZm9sbG93aW5nIHJlc2l6ZSBldmVudFxuXHRcdFx0dGhpcy5fZnNUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoICgpID0+IHtcblx0XHRcdFx0dGhpcy5fZnNDaGFuZ2luZyA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9mc1RpbWVvdXQgPSAwO1xuXHRcdFx0fSwgNjAgKTtcblx0XHR9KTtcblxuXHRcdC8vIFJlc3VtZSBhdWRpbyBjb250ZXh0IGlmIGluIHN1c3BlbmRlZCBzdGF0ZSAoYnJvd3NlcnMnIGF1dG9wbGF5IHBvbGljeSlcblx0XHRjb25zdCB1bmxvY2tDb250ZXh0ID0gKCkgPT4ge1xuXHRcdFx0aWYgKCBhdWRpb0N0eC5zdGF0ZSA9PSAnc3VzcGVuZGVkJyApXG5cdFx0XHRcdGF1ZGlvQ3R4LnJlc3VtZSgpO1xuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjbGljaycsIHVubG9ja0NvbnRleHQgKTtcblx0XHR9XG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIHVubG9ja0NvbnRleHQgKTtcblxuXHRcdC8vIGluaXRpYWxpemUgaW50ZXJuYWwgdmFyaWFibGVzXG5cdFx0dGhpcy5fY2FsY0F1eCgpO1xuXG5cdFx0Ly8gU2V0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBhbmQgdXNlIGRlZmF1bHRzIGZvciBhbnkgbWlzc2luZyBwcm9wZXJ0aWVzXG5cdFx0dGhpcy5fc2V0UHJvcHMoIG9wdGlvbnMsIHRydWUgKTtcblxuXHRcdC8vIGFkZCBjYW52YXMgdG8gdGhlIGNvbnRhaW5lclxuXHRcdGlmICggdGhpcy51c2VDYW52YXMgKVxuXHRcdFx0dGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKCBjYW52YXMgKTtcblxuXHRcdC8vIEZpbmlzaCBjYW52YXMgc2V0dXBcblx0XHR0aGlzLl9yZWFkeSA9IHRydWU7XG5cdFx0dGhpcy5fc2V0Q2FudmFzKCdjcmVhdGUnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXHQgKlxuXHQgKiBQVUJMSUMgUFJPUEVSVElFUyBHRVRURVJTIEFORCBTRVRURVJTXG5cdCAqXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqL1xuXG5cblx0Z2V0IGFscGhhQmFycygpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWxwaGFCYXJzO1xuXHR9XG5cdHNldCBhbHBoYUJhcnMoIHZhbHVlICkge1xuXHRcdHRoaXMuX2FscGhhQmFycyA9ICEhIHZhbHVlO1xuXHRcdHRoaXMuX2NhbGNBdXgoKTtcblx0fVxuXG5cdGdldCBiYXJTcGFjZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fYmFyU3BhY2U7XG5cdH1cblx0c2V0IGJhclNwYWNlKCB2YWx1ZSApIHtcblx0XHR0aGlzLl9iYXJTcGFjZSA9ICt2YWx1ZSB8fCAwO1xuXHRcdHRoaXMuX2NhbGNBdXgoKTtcblx0fVxuXG5cdGdldCBmZnRTaXplKCkge1xuXHRcdHJldHVybiB0aGlzLl9hbmFseXplclswXS5mZnRTaXplO1xuXHR9XG5cdHNldCBmZnRTaXplKCB2YWx1ZSApIHtcblx0XHRmb3IgKCBjb25zdCBpIG9mIFswLDFdIClcblx0XHRcdHRoaXMuX2FuYWx5emVyWyBpIF0uZmZ0U2l6ZSA9IHZhbHVlO1xuXHRcdGNvbnN0IGJpbkNvdW50ID0gdGhpcy5fYW5hbHl6ZXJbMF0uZnJlcXVlbmN5QmluQ291bnQ7XG5cdFx0dGhpcy5fZmZ0RGF0YSA9IFsgbmV3IFVpbnQ4QXJyYXkoIGJpbkNvdW50ICksIG5ldyBVaW50OEFycmF5KCBiaW5Db3VudCApIF07XG5cdFx0dGhpcy5fY2FsY0JhcnMoKTtcblx0fVxuXG5cdGdldCBncmFkaWVudCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZ3JhZGllbnQ7XG5cdH1cblx0c2V0IGdyYWRpZW50KCB2YWx1ZSApIHtcblx0XHRpZiAoICEgdGhpcy5fZ3JhZGllbnRzLmhhc093blByb3BlcnR5KCB2YWx1ZSApIClcblx0XHRcdHRocm93IG5ldyBBdWRpb01vdGlvbkVycm9yKCAnRVJSX1VOS05PV05fR1JBRElFTlQnLCBgVW5rbm93biBncmFkaWVudDogJyR7dmFsdWV9J2AgKTtcblxuXHRcdHRoaXMuX2dyYWRpZW50ID0gdmFsdWU7XG5cdFx0dGhpcy5fbWFrZUdyYWQoKTtcblx0fVxuXG5cdGdldCBoZWlnaHQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hlaWdodDtcblx0fVxuXHRzZXQgaGVpZ2h0KCBoICkge1xuXHRcdHRoaXMuX2hlaWdodCA9IGg7XG5cdFx0dGhpcy5fc2V0Q2FudmFzKCd1c2VyJyk7XG5cdH1cblxuXHRnZXQgbGVkQmFycygpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2hvd0xlZHM7XG5cdH1cblx0c2V0IGxlZEJhcnMoIHZhbHVlICkge1xuXHRcdHRoaXMuX3Nob3dMZWRzID0gISEgdmFsdWU7XG5cdFx0dGhpcy5fY2FsY0F1eCgpO1xuXHR9XG5cblx0Z2V0IGxvUmVzKCkge1xuXHRcdHJldHVybiB0aGlzLl9sb1Jlcztcblx0fVxuXHRzZXQgbG9SZXMoIHZhbHVlICkge1xuXHRcdHRoaXMuX2xvUmVzID0gISEgdmFsdWU7XG5cdFx0dGhpcy5fc2V0Q2FudmFzKCdsb3JlcycpO1xuXHR9XG5cblx0Z2V0IGx1bWlCYXJzKCkge1xuXHRcdHJldHVybiB0aGlzLl9sdW1pQmFycztcblx0fVxuXHRzZXQgbHVtaUJhcnMoIHZhbHVlICkge1xuXHRcdHRoaXMuX2x1bWlCYXJzID0gISEgdmFsdWU7XG5cdFx0dGhpcy5fY2FsY0F1eCgpO1xuXHRcdHRoaXMuX2NhbGNMZWRzKCk7XG5cdFx0dGhpcy5fbWFrZUdyYWQoKTtcblx0fVxuXG5cdGdldCBtYXhEZWNpYmVscygpIHtcblx0XHRyZXR1cm4gdGhpcy5fYW5hbHl6ZXJbMF0ubWF4RGVjaWJlbHM7XG5cdH1cblx0c2V0IG1heERlY2liZWxzKCB2YWx1ZSApIHtcblx0XHRmb3IgKCBjb25zdCBpIG9mIFswLDFdIClcblx0XHRcdHRoaXMuX2FuYWx5emVyWyBpIF0ubWF4RGVjaWJlbHMgPSB2YWx1ZTtcblx0fVxuXG5cdGdldCBtYXhGcmVxKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXhGcmVxO1xuXHR9XG5cdHNldCBtYXhGcmVxKCB2YWx1ZSApIHtcblx0XHRpZiAoIHZhbHVlIDwgMSApXG5cdFx0XHR0aHJvdyBuZXcgQXVkaW9Nb3Rpb25FcnJvciggJ0VSUl9GUkVRVUVOQ1lfVE9PX0xPVycsIGBGcmVxdWVuY3kgdmFsdWVzIG11c3QgYmUgPj0gMWAgKTtcblx0XHRlbHNlIHtcblx0XHRcdHRoaXMuX21heEZyZXEgPSB2YWx1ZTtcblx0XHRcdHRoaXMuX2NhbGNCYXJzKCk7XG5cdFx0fVxuXHR9XG5cblx0Z2V0IG1pbkRlY2liZWxzKCkge1xuXHRcdHJldHVybiB0aGlzLl9hbmFseXplclswXS5taW5EZWNpYmVscztcblx0fVxuXHRzZXQgbWluRGVjaWJlbHMoIHZhbHVlICkge1xuXHRcdGZvciAoIGNvbnN0IGkgb2YgWzAsMV0gKVxuXHRcdFx0dGhpcy5fYW5hbHl6ZXJbIGkgXS5taW5EZWNpYmVscyA9IHZhbHVlO1xuXHR9XG5cblx0Z2V0IG1pbkZyZXEoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21pbkZyZXE7XG5cdH1cblx0c2V0IG1pbkZyZXEoIHZhbHVlICkge1xuXHRcdGlmICggdmFsdWUgPCAxIClcblx0XHRcdHRocm93IG5ldyBBdWRpb01vdGlvbkVycm9yKCAnRVJSX0ZSRVFVRU5DWV9UT09fTE9XJywgYEZyZXF1ZW5jeSB2YWx1ZXMgbXVzdCBiZSA+PSAxYCApO1xuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5fbWluRnJlcSA9IHZhbHVlO1xuXHRcdFx0dGhpcy5fY2FsY0JhcnMoKTtcblx0XHR9XG5cdH1cblxuXHRnZXQgbWlycm9yKCkge1xuXHRcdHJldHVybiB0aGlzLl9taXJyb3I7XG5cdH1cblx0c2V0IG1pcnJvciggdmFsdWUgKSB7XG5cdFx0dGhpcy5fbWlycm9yID0gTWF0aC5zaWduKCB2YWx1ZSApIHwgMDsgLy8gZW5zdXJlIG9ubHkgLTEsIDAgb3IgMVxuXHRcdHRoaXMuX2NhbGNBdXgoKTtcblx0XHR0aGlzLl9jYWxjQmFycygpO1xuXHRcdHRoaXMuX21ha2VHcmFkKCk7XG5cdH1cblxuXHRnZXQgbW9kZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbW9kZTtcblx0fVxuXHRzZXQgbW9kZSggdmFsdWUgKSB7XG5cdFx0Y29uc3QgbW9kZSA9IHZhbHVlIHwgMDtcblx0XHRpZiAoIG1vZGUgPj0gMCAmJiBtb2RlIDw9IDEwICYmIG1vZGUgIT0gOSApIHtcblx0XHRcdHRoaXMuX21vZGUgPSBtb2RlO1xuXHRcdFx0dGhpcy5fY2FsY0F1eCgpO1xuXHRcdFx0dGhpcy5fY2FsY0JhcnMoKTtcblx0XHRcdHRoaXMuX21ha2VHcmFkKCk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHRcdHRocm93IG5ldyBBdWRpb01vdGlvbkVycm9yKCAnRVJSX0lOVkFMSURfTU9ERScsIGBJbnZhbGlkIG1vZGU6ICR7dmFsdWV9YCApO1xuXHR9XG5cblx0Z2V0IG91dGxpbmVCYXJzKCkge1xuXHRcdHJldHVybiB0aGlzLl9vdXRsaW5lQmFycztcblx0fVxuXHRzZXQgb3V0bGluZUJhcnMoIHZhbHVlICkge1xuXHRcdHRoaXMuX291dGxpbmVCYXJzID0gISEgdmFsdWU7XG5cdFx0dGhpcy5fY2FsY0F1eCgpO1xuXHR9XG5cblx0Z2V0IHJhZGlhbCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaWFsO1xuXHR9XG5cdHNldCByYWRpYWwoIHZhbHVlICkge1xuXHRcdHRoaXMuX3JhZGlhbCA9ICEhIHZhbHVlO1xuXHRcdHRoaXMuX2NhbGNBdXgoKTtcblx0XHR0aGlzLl9jYWxjQmFycygpO1xuXHRcdHRoaXMuX21ha2VHcmFkKCk7XG5cdH1cblxuXHRnZXQgcmVmbGV4UmF0aW8oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JlZmxleFJhdGlvO1xuXHR9XG5cdHNldCByZWZsZXhSYXRpbyggdmFsdWUgKSB7XG5cdFx0dmFsdWUgPSArdmFsdWUgfHwgMDtcblx0XHRpZiAoIHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIClcblx0XHRcdHRocm93IG5ldyBBdWRpb01vdGlvbkVycm9yKCAnRVJSX1JFRkxFWF9PVVRfT0ZfUkFOR0UnLCBgUmVmbGV4IHJhdGlvIG11c3QgYmUgPj0gMCBhbmQgPCAxYCApO1xuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVmbGV4UmF0aW8gPSB2YWx1ZTtcblx0XHRcdHRoaXMuX2NhbGNBdXgoKTtcblx0XHRcdHRoaXMuX21ha2VHcmFkKCk7XG5cdFx0XHR0aGlzLl9jYWxjTGVkcygpO1xuXHRcdH1cblx0fVxuXG5cdC8vIERFUFJFQ0FURUQgLSB1c2UgbGVkQmFycyBpbnN0ZWFkXG5cdGdldCBzaG93TGVkcygpIHtcblx0XHRyZXR1cm4gdGhpcy5sZWRCYXJzO1xuXHR9XG5cdHNldCBzaG93TGVkcyggdmFsdWUgKSB7XG5cdFx0dGhpcy5sZWRCYXJzID0gdmFsdWU7XG5cdH1cblxuXHRnZXQgc21vb3RoaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLl9hbmFseXplclswXS5zbW9vdGhpbmdUaW1lQ29uc3RhbnQ7XG5cdH1cblx0c2V0IHNtb290aGluZyggdmFsdWUgKSB7XG5cdFx0Zm9yICggY29uc3QgaSBvZiBbMCwxXSApXG5cdFx0XHR0aGlzLl9hbmFseXplclsgaSBdLnNtb290aGluZ1RpbWVDb25zdGFudCA9IHZhbHVlO1xuXHR9XG5cblx0Z2V0IHNwaW5TcGVlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3BpblNwZWVkO1xuXHR9XG5cdHNldCBzcGluU3BlZWQoIHZhbHVlICkge1xuXHRcdHZhbHVlID0gK3ZhbHVlIHx8IDA7XG5cdFx0aWYgKCB0aGlzLl9zcGluU3BlZWQgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PSAwIClcblx0XHRcdHRoaXMuX3NwaW5BbmdsZSA9IC1IQUxGX1BJOyAvLyBpbml0aWFsaXplIG9yIHJlc2V0IHRoZSByb3RhdGlvbiBhbmdsZVxuXHRcdHRoaXMuX3NwaW5TcGVlZCA9IHZhbHVlO1xuXHR9XG5cblx0Z2V0IHNwbGl0R3JhZGllbnQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NwbGl0R3JhZGllbnQ7XG5cdH1cblx0c2V0IHNwbGl0R3JhZGllbnQoIHZhbHVlICkge1xuXHRcdHRoaXMuX3NwbGl0R3JhZGllbnQgPSAhISB2YWx1ZTtcblx0XHR0aGlzLl9tYWtlR3JhZCgpO1xuXHR9XG5cblx0Z2V0IHN0ZXJlbygpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3RlcmVvO1xuXHR9XG5cdHNldCBzdGVyZW8oIHZhbHVlICkge1xuXHRcdHRoaXMuX3N0ZXJlbyA9ICEhIHZhbHVlO1xuXG5cdFx0Ly8gdXBkYXRlIG5vZGUgY29ubmVjdGlvbnNcblx0XHR0aGlzLl9pbnB1dC5kaXNjb25uZWN0KCk7XG5cdFx0dGhpcy5faW5wdXQuY29ubmVjdCggdGhpcy5fc3RlcmVvID8gdGhpcy5fc3BsaXR0ZXIgOiB0aGlzLl9hbmFseXplclswXSApO1xuXHRcdHRoaXMuX2FuYWx5emVyWzBdLmRpc2Nvbm5lY3QoKTtcblx0XHRpZiAoIHRoaXMuX291dE5vZGVzLmxlbmd0aCApIC8vIGNvbm5lY3QgYW5hbHl6ZXIgb25seSBpZiB0aGUgb3V0cHV0IGlzIGNvbm5lY3RlZCB0byBvdGhlciBub2Rlc1xuXHRcdFx0dGhpcy5fYW5hbHl6ZXJbMF0uY29ubmVjdCggdGhpcy5fc3RlcmVvID8gdGhpcy5fbWVyZ2VyIDogdGhpcy5fb3V0cHV0ICk7XG5cblx0XHQvLyB1cGRhdGUgcHJvcGVydGllcyBhZmZlY3RlZCBieSBzdGVyZW9cblx0XHR0aGlzLl9jYWxjQXV4KCk7XG5cdFx0dGhpcy5fY3JlYXRlU2NhbGVzKCk7XG5cdFx0dGhpcy5fY2FsY0xlZHMoKTtcblx0XHR0aGlzLl9tYWtlR3JhZCgpO1xuXHR9XG5cblx0Z2V0IHZvbHVtZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5fb3V0cHV0LmdhaW4udmFsdWU7XG5cdH1cblx0c2V0IHZvbHVtZSggdmFsdWUgKSB7XG5cdFx0dGhpcy5fb3V0cHV0LmdhaW4udmFsdWUgPSB2YWx1ZTtcblx0fVxuXG5cdGdldCB3aWR0aCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fd2lkdGg7XG5cdH1cblx0c2V0IHdpZHRoKCB3ICkge1xuXHRcdHRoaXMuX3dpZHRoID0gdztcblx0XHR0aGlzLl9zZXRDYW52YXMoJ3VzZXInKTtcblx0fVxuXG5cdC8vIFJlYWQgb25seSBwcm9wZXJ0aWVzXG5cblx0Z2V0IGF1ZGlvQ3R4KCkge1xuXHRcdHJldHVybiB0aGlzLl9pbnB1dC5jb250ZXh0O1xuXHR9XG5cdGdldCBjYW52YXMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NhbnZhc0N0eC5jYW52YXM7XG5cdH1cblx0Z2V0IGNhbnZhc0N0eCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2FudmFzQ3R4O1xuXHR9XG5cdGdldCBjb25uZWN0ZWRTb3VyY2VzKCkge1xuXHRcdHJldHVybiB0aGlzLl9zb3VyY2VzO1xuXHR9XG5cdGdldCBjb25uZWN0ZWRUbygpIHtcblx0XHRyZXR1cm4gdGhpcy5fb3V0Tm9kZXM7XG5cdH1cblx0Z2V0IGVuZXJneSgpIHsgLy8gREVQUkVDQVRFRCAtIHVzZSBnZXRFbmVyZ3koKSBpbnN0ZWFkXG5cdFx0cmV0dXJuIHRoaXMuZ2V0RW5lcmd5KCk7XG5cdH1cblx0Z2V0IGZwcygpIHtcblx0XHRyZXR1cm4gdGhpcy5fZnBzO1xuXHR9XG5cdGdldCBmc0hlaWdodCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fZnNIZWlnaHQ7XG5cdH1cblx0Z2V0IGZzV2lkdGgoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ZzV2lkdGg7XG5cdH1cblx0Z2V0IGlzQWxwaGFCYXJzKCkge1xuXHRcdHJldHVybiB0aGlzLl9pc0FscGhhQmFycztcblx0fVxuXHRnZXQgaXNGdWxsc2NyZWVuKCkge1xuXHRcdHJldHVybiAoIGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50ICkgPT09IHRoaXMuX2ZzRWw7XG5cdH1cblx0Z2V0IGlzTGVkQmFycygpIHtcblx0XHRyZXR1cm4gdGhpcy5faXNMZWREaXNwbGF5O1xuXHR9XG5cdGdldCBpc0xlZERpc3BsYXkoKSB7IC8vIERFUFJFQ0FURUQgLSB1c2UgaXNMZWRCYXJzIGluc3RlYWRcblx0XHRyZXR1cm4gdGhpcy5pc0xlZEJhcnM7XG5cdH1cblx0Z2V0IGlzTHVtaUJhcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lzTHVtaUJhcnM7XG5cdH1cblx0Z2V0IGlzT2N0YXZlQmFuZHMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lzT2N0YXZlQmFuZHM7XG5cdH1cblx0Z2V0IGlzT24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3J1bklkICE9PSB1bmRlZmluZWQ7XG5cdH1cblx0Z2V0IGlzT3V0bGluZUJhcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lzT3V0bGluZTtcblx0fVxuXHRnZXQgcGVha0VuZXJneSgpIHsgLy8gREVQUkVDQVRFRCAtIHVzZSBnZXRFbmVyZ3koJ3BlYWsnKSBpbnN0ZWFkXG5cdFx0cmV0dXJuIHRoaXMuZ2V0RW5lcmd5KCdwZWFrJyk7XG5cdH1cblx0Z2V0IHBpeGVsUmF0aW8oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BpeGVsUmF0aW87XG5cdH1cblx0c3RhdGljIGdldCB2ZXJzaW9uKCkge1xuXHRcdHJldHVybiBWRVJTSU9OO1xuXHR9XG5cblx0LyoqXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICpcblx0ICogUFVCTElDIE1FVEhPRFNcblx0ICpcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICovXG5cblx0LyoqXG5cdCAqIENvbm5lY3RzIGFuIEhUTUwgbWVkaWEgZWxlbWVudCBvciBhdWRpbyBub2RlIHRvIHRoZSBhbmFseXplclxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gYW4gaW5zdGFuY2Ugb2YgSFRNTE1lZGlhRWxlbWVudCBvciBBdWRpb05vZGVcblx0ICogQHJldHVybnMge29iamVjdH0gYSBNZWRpYUVsZW1lbnRBdWRpb1NvdXJjZU5vZGUgb2JqZWN0IGlmIGNyZWF0ZWQgZnJvbSBIVE1MIGVsZW1lbnQsIG9yIHRoZSBzYW1lIGlucHV0IG9iamVjdCBvdGhlcndpc2Vcblx0ICovXG5cdGNvbm5lY3RJbnB1dCggc291cmNlICkge1xuXHRcdGNvbnN0IGlzSFRNTCA9IHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxNZWRpYUVsZW1lbnQ7XG5cblx0XHRpZiAoICEgKCBpc0hUTUwgfHwgc291cmNlLmNvbm5lY3QgKSApXG5cdFx0XHR0aHJvdyBuZXcgQXVkaW9Nb3Rpb25FcnJvciggJ0VSUl9JTlZBTElEX0FVRElPX1NPVVJDRScsICdBdWRpbyBzb3VyY2UgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBIVE1MTWVkaWFFbGVtZW50IG9yIEF1ZGlvTm9kZScgKTtcblxuXHRcdC8vIGlmIHNvdXJjZSBpcyBhbiBIVE1MIGVsZW1lbnQsIGNyZWF0ZSBhbiBhdWRpbyBub2RlIGZvciBpdDsgb3RoZXJ3aXNlLCB1c2UgdGhlIHByb3ZpZGVkIGF1ZGlvIG5vZGVcblx0XHRjb25zdCBub2RlID0gaXNIVE1MID8gdGhpcy5hdWRpb0N0eC5jcmVhdGVNZWRpYUVsZW1lbnRTb3VyY2UoIHNvdXJjZSApIDogc291cmNlO1xuXG5cdFx0aWYgKCAhIHRoaXMuX3NvdXJjZXMuaW5jbHVkZXMoIG5vZGUgKSApIHtcblx0XHRcdG5vZGUuY29ubmVjdCggdGhpcy5faW5wdXQgKTtcblx0XHRcdHRoaXMuX3NvdXJjZXMucHVzaCggbm9kZSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbm5lY3RzIHRoZSBhbmFseXplciBvdXRwdXQgdG8gYW5vdGhlciBhdWRpbyBub2RlXG5cdCAqXG5cdCAqIEBwYXJhbSBbe29iamVjdH1dIGFuIEF1ZGlvTm9kZTsgaWYgdW5kZWZpbmVkLCB0aGUgb3V0cHV0IGlzIGNvbm5lY3RlZCB0byB0aGUgYXVkaW8gY29udGV4dCBkZXN0aW5hdGlvbiAoc3BlYWtlcnMpXG5cdCAqL1xuXHRjb25uZWN0T3V0cHV0KCBub2RlID0gdGhpcy5hdWRpb0N0eC5kZXN0aW5hdGlvbiApIHtcblx0XHRpZiAoIHRoaXMuX291dE5vZGVzLmluY2x1ZGVzKCBub2RlICkgKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dGhpcy5fb3V0cHV0LmNvbm5lY3QoIG5vZGUgKTtcblx0XHR0aGlzLl9vdXROb2Rlcy5wdXNoKCBub2RlICk7XG5cblx0XHQvLyB3aGVuIGNvbm5lY3RpbmcgdGhlIGZpcnN0IG5vZGUsIGFsc28gY29ubmVjdCB0aGUgYW5hbHl6ZXIgbm9kZXMgdG8gdGhlIG1lcmdlciAvIG91dHB1dCBub2Rlc1xuXHRcdGlmICggdGhpcy5fb3V0Tm9kZXMubGVuZ3RoID09IDEgKSB7XG5cdFx0XHRmb3IgKCBjb25zdCBpIG9mIFswLDFdIClcblx0XHRcdFx0dGhpcy5fYW5hbHl6ZXJbIGkgXS5jb25uZWN0KCAoICEgdGhpcy5fc3RlcmVvICYmICEgaSA/IHRoaXMuX291dHB1dCA6IHRoaXMuX21lcmdlciApLCAwLCBpICk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIERpc2Nvbm5lY3RzIGF1ZGlvIHNvdXJjZXMgZnJvbSB0aGUgYW5hbHl6ZXJcblx0ICpcblx0ICogQHBhcmFtIFt7b2JqZWN0fGFycmF5fV0gYSBjb25uZWN0ZWQgQXVkaW9Ob2RlIG9iamVjdCBvciBhbiBhcnJheSBvZiBzdWNoIG9iamVjdHM7IGlmIHVuZGVmaW5lZCwgYWxsIGNvbm5lY3RlZCBub2RlcyBhcmUgZGlzY29ubmVjdGVkXG5cdCAqL1xuXHRkaXNjb25uZWN0SW5wdXQoIHNvdXJjZXMgKSB7XG5cdFx0aWYgKCAhIHNvdXJjZXMgKVxuXHRcdFx0c291cmNlcyA9IEFycmF5LmZyb20oIHRoaXMuX3NvdXJjZXMgKTtcblx0XHRlbHNlIGlmICggISBBcnJheS5pc0FycmF5KCBzb3VyY2VzICkgKVxuXHRcdFx0c291cmNlcyA9IFsgc291cmNlcyBdO1xuXG5cdFx0Zm9yICggY29uc3Qgbm9kZSBvZiBzb3VyY2VzICkge1xuXHRcdFx0Y29uc3QgaWR4ID0gdGhpcy5fc291cmNlcy5pbmRleE9mKCBub2RlICk7XG5cdFx0XHRpZiAoIGlkeCA+PSAwICkge1xuXHRcdFx0XHRub2RlLmRpc2Nvbm5lY3QoIHRoaXMuX2lucHV0ICk7XG5cdFx0XHRcdHRoaXMuX3NvdXJjZXMuc3BsaWNlKCBpZHgsIDEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRGlzY29ubmVjdHMgdGhlIGFuYWx5emVyIG91dHB1dCBmcm9tIG90aGVyIGF1ZGlvIG5vZGVzXG5cdCAqXG5cdCAqIEBwYXJhbSBbe29iamVjdH1dIGEgY29ubmVjdGVkIEF1ZGlvTm9kZSBvYmplY3Q7IGlmIHVuZGVmaW5lZCwgYWxsIGNvbm5lY3RlZCBub2RlcyBhcmUgZGlzY29ubmVjdGVkXG5cdCAqL1xuXHRkaXNjb25uZWN0T3V0cHV0KCBub2RlICkge1xuXHRcdGlmICggbm9kZSAmJiAhIHRoaXMuX291dE5vZGVzLmluY2x1ZGVzKCBub2RlICkgKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dGhpcy5fb3V0cHV0LmRpc2Nvbm5lY3QoIG5vZGUgKTtcblx0XHR0aGlzLl9vdXROb2RlcyA9IG5vZGUgPyB0aGlzLl9vdXROb2Rlcy5maWx0ZXIoIGUgPT4gZSAhPT0gbm9kZSApIDogW107XG5cblx0XHQvLyBpZiBkaXNjb25uZWN0ZWQgZnJvbSBhbGwgbm9kZXMsIGFsc28gZGlzY29ubmVjdCB0aGUgYW5hbHl6ZXIgbm9kZXMgc28gdGhleSBrZWVwIHdvcmtpbmcgb24gQ2hyb21pdW1cblx0XHQvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2h2aWFubmEvYXVkaW9Nb3Rpb24tYW5hbHl6ZXIvaXNzdWVzLzEzI2lzc3VlY29tbWVudC04MDg3NjQ4NDhcblx0XHRpZiAoIHRoaXMuX291dE5vZGVzLmxlbmd0aCA9PSAwICkge1xuXHRcdFx0Zm9yICggY29uc3QgaSBvZiBbMCwxXSApXG5cdFx0XHRcdHRoaXMuX2FuYWx5emVyWyBpIF0uZGlzY29ubmVjdCgpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGFuYWx5emVyIGJhcnMgZGF0YVxuICAgICAqXG5cdCAqIEByZXR1cm5zIHthcnJheX1cblx0ICovXG5cdGdldEJhcnMoKSB7XG5cdFx0cmV0dXJuIEFycmF5LmZyb20oIHRoaXMuX2JhcnMsICggeyBwb3NYLCBmcmVxTG8sIGZyZXFIaSwgaG9sZCwgcGVhaywgdmFsdWUgfSApID0+ICggeyBwb3NYLCBmcmVxTG8sIGZyZXFIaSwgaG9sZCwgcGVhaywgdmFsdWUgfSApICk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZW5lcmd5IG9mIGEgZnJlcXVlbmN5LCBvciBhdmVyYWdlIGVuZXJneSBvZiBhIHJhbmdlIG9mIGZyZXF1ZW5jaWVzXG5cdCAqXG5cdCAqIEBwYXJhbSBbe251bWJlcnxzdHJpbmd9XSBzaW5nbGUgb3IgaW5pdGlhbCBmcmVxdWVuY3kgKEh6KSwgb3IgcHJlc2V0IG5hbWU7IGlmIHVuZGVmaW5lZCwgcmV0dXJucyB0aGUgb3ZlcmFsbCBlbmVyZ3lcblx0ICogQHBhcmFtIFt7bnVtYmVyfV0gZW5kaW5nIGZyZXF1ZW5jeSAoSHopXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ8bnVsbH0gZW5lcmd5IHZhbHVlICgwIHRvIDEpIG9yIG51bGwsIGlmIHRoZSBzcGVjaWZpZWQgcHJlc2V0IGlzIHVua25vd25cblx0ICovXG5cdGdldEVuZXJneSggc3RhcnRGcmVxLCBlbmRGcmVxICkge1xuXHRcdGlmICggc3RhcnRGcmVxID09PSB1bmRlZmluZWQgKVxuXHRcdFx0cmV0dXJuIHRoaXMuX2VuZXJneS52YWw7XG5cblx0XHQvLyBpZiBzdGFydEZyZXEgaXMgYSBzdHJpbmcsIGNoZWNrIGZvciBwcmVzZXRzXG5cdFx0aWYgKCBzdGFydEZyZXEgIT0gK3N0YXJ0RnJlcSApIHtcblx0XHRcdGlmICggc3RhcnRGcmVxID09ICdwZWFrJyApXG5cdFx0XHRcdHJldHVybiB0aGlzLl9lbmVyZ3kucGVhaztcblxuXHRcdFx0Y29uc3QgcHJlc2V0cyA9IHtcblx0XHRcdFx0YmFzczogICAgWyAyMCwgMjUwIF0sXG5cdFx0XHRcdGxvd01pZDogIFsgMjUwLCA1MDAgXSxcblx0XHRcdFx0bWlkOiAgICAgWyA1MDAsIDJlMyBdLFxuXHRcdFx0XHRoaWdoTWlkOiBbIDJlMywgNGUzIF0sXG5cdFx0XHRcdHRyZWJsZTogIFsgNGUzLCAxNmUzIF1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhIHByZXNldHNbIHN0YXJ0RnJlcSBdIClcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHRcdFsgc3RhcnRGcmVxLCBlbmRGcmVxIF0gPSBwcmVzZXRzWyBzdGFydEZyZXEgXTtcblx0XHR9XG5cblx0XHRjb25zdCBzdGFydEJpbiA9IHRoaXMuX2ZyZXFUb0Jpbiggc3RhcnRGcmVxICksXG5cdFx0ICAgICAgZW5kQmluICAgPSBlbmRGcmVxID8gdGhpcy5fZnJlcVRvQmluKCBlbmRGcmVxICkgOiBzdGFydEJpbixcblx0XHQgICAgICBjaG5Db3VudCA9IHRoaXMuX3N0ZXJlbyArIDE7XG5cblx0XHRsZXQgZW5lcmd5ID0gMDtcblx0XHRmb3IgKCBsZXQgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCBjaG5Db3VudDsgY2hhbm5lbCsrICkge1xuXHRcdFx0Zm9yICggbGV0IGkgPSBzdGFydEJpbjsgaSA8PSBlbmRCaW47IGkrKyApXG5cdFx0XHRcdGVuZXJneSArPSB0aGlzLl9mZnREYXRhWyBjaGFubmVsIF1bIGkgXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZW5lcmd5IC8gKCBlbmRCaW4gLSBzdGFydEJpbiArIDEgKSAvIGNobkNvdW50IC8gMjU1O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBhIGN1c3RvbSBncmFkaWVudFxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuXHQgKi9cblx0cmVnaXN0ZXJHcmFkaWVudCggbmFtZSwgb3B0aW9ucyApIHtcblx0XHRpZiAoIHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyB8fCBuYW1lLnRyaW0oKS5sZW5ndGggPT0gMCApXG5cdFx0XHR0aHJvdyBuZXcgQXVkaW9Nb3Rpb25FcnJvciggJ0VSUl9HUkFESUVOVF9JTlZBTElEX05BTUUnLCAnR3JhZGllbnQgbmFtZSBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZycgKTtcblxuXHRcdGlmICggdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnIClcblx0XHRcdHRocm93IG5ldyBBdWRpb01vdGlvbkVycm9yKCAnRVJSX0dSQURJRU5UX05PVF9BTl9PQkpFQ1QnLCAnR3JhZGllbnQgb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcgKTtcblxuXHRcdGlmICggb3B0aW9ucy5jb2xvclN0b3BzID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5jb2xvclN0b3BzLmxlbmd0aCA8IDIgKVxuXHRcdFx0dGhyb3cgbmV3IEF1ZGlvTW90aW9uRXJyb3IoICdFUlJfR1JBRElFTlRfTUlTU0lOR19DT0xPUicsICdHcmFkaWVudCBtdXN0IGRlZmluZSBhdCBsZWFzdCB0d28gY29sb3JzJyApO1xuXG5cdFx0dGhpcy5fZ3JhZGllbnRzWyBuYW1lIF0gPSB7XG5cdFx0XHRiZ0NvbG9yOiAgICBvcHRpb25zLmJnQ29sb3IgfHwgJyMxMTEnLFxuXHRcdFx0ZGlyOiAgICAgICAgb3B0aW9ucy5kaXIsXG5cdFx0XHRjb2xvclN0b3BzOiBvcHRpb25zLmNvbG9yU3RvcHNcblx0XHR9O1xuXG5cdFx0Ly8gaWYgdGhlIHJlZ2lzdGVyZWQgZ3JhZGllbnQgaXMgdGhlIGN1cnJlbnQgb25lLCByZWdlbmVyYXRlIGl0XG5cdFx0aWYgKCBuYW1lID09IHRoaXMuX2dyYWRpZW50IClcblx0XHRcdHRoaXMuX21ha2VHcmFkKCk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IGRpbWVuc2lvbnMgb2YgYW5hbHl6ZXIncyBjYW52YXNcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHcgd2lkdGggaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoIGhlaWdodCBpbiBwaXhlbHNcblx0ICovXG5cdHNldENhbnZhc1NpemUoIHcsIGggKSB7XG5cdFx0dGhpcy5fd2lkdGggPSB3O1xuXHRcdHRoaXMuX2hlaWdodCA9IGg7XG5cdFx0dGhpcy5fc2V0Q2FudmFzKCd1c2VyJyk7XG5cdH1cblxuXHQvKipcblx0ICogU2V0IGRlc2lyZWQgZnJlcXVlbmN5IHJhbmdlXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gbG93ZXN0IGZyZXF1ZW5jeSByZXByZXNlbnRlZCBpbiB0aGUgeC1heGlzXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXggaGlnaGVzdCBmcmVxdWVuY3kgcmVwcmVzZW50ZWQgaW4gdGhlIHgtYXhpc1xuXHQgKi9cblx0c2V0RnJlcVJhbmdlKCBtaW4sIG1heCApIHtcblx0XHRpZiAoIG1pbiA8IDEgfHwgbWF4IDwgMSApXG5cdFx0XHR0aHJvdyBuZXcgQXVkaW9Nb3Rpb25FcnJvciggJ0VSUl9GUkVRVUVOQ1lfVE9PX0xPVycsIGBGcmVxdWVuY3kgdmFsdWVzIG11c3QgYmUgPj0gMWAgKTtcblx0XHRlbHNlIHtcblx0XHRcdHRoaXMuX21pbkZyZXEgPSBNYXRoLm1pbiggbWluLCBtYXggKTtcblx0XHRcdHRoaXMuX21heEZyZXEgPSBNYXRoLm1heCggbWluLCBtYXggKTtcblx0XHRcdHRoaXMuX2NhbGNCYXJzKCk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldCBjdXN0b20gcGFyYW1ldGVycyBmb3IgTEVEIGVmZmVjdFxuXHQgKiBJZiBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMgb3IgaWYgYW55IHByb3BlcnR5IGlzIGludmFsaWQsIGNsZWFycyBhbnkgcHJldmlvdXMgY3VzdG9tIHBhcmFtZXRlcnNcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdXG5cdCAqL1xuXHRzZXRMZWRQYXJhbXMoIHBhcmFtcyApIHtcblx0XHRsZXQgbWF4TGVkcywgc3BhY2VWLCBzcGFjZUg7XG5cblx0XHQvLyBjb2VyY2UgcGFyYW1ldGVycyB0byBOdW1iZXI7IGBOYU5gIHJlc3VsdHMgYXJlIHJlamVjdGVkIGluIHRoZSBjb25kaXRpb24gYmVsb3dcblx0XHRpZiAoIHBhcmFtcyApIHtcblx0XHRcdG1heExlZHMgPSBwYXJhbXMubWF4TGVkcyB8IDAsIC8vIGVuc3VyZSBpbnRlZ2VyXG5cdFx0XHRzcGFjZVYgID0gK3BhcmFtcy5zcGFjZVYsXG5cdFx0XHRzcGFjZUggID0gK3BhcmFtcy5zcGFjZUg7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbGVkUGFyYW1zID0gbWF4TGVkcyA+IDAgJiYgc3BhY2VWID4gMCAmJiBzcGFjZUggPj0gMCA/IFsgbWF4TGVkcywgc3BhY2VWLCBzcGFjZUggXSA6IHVuZGVmaW5lZDtcblx0XHR0aGlzLl9jYWxjTGVkcygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNob3J0aGFuZCBmdW5jdGlvbiBmb3Igc2V0dGluZyBzZXZlcmFsIG9wdGlvbnMgYXQgb25jZVxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuXHQgKi9cblx0c2V0T3B0aW9ucyggb3B0aW9ucyApIHtcblx0XHR0aGlzLl9zZXRQcm9wcyggb3B0aW9ucyApO1xuXHR9XG5cblx0LyoqXG5cdCAqIEFkanVzdCB0aGUgYW5hbHl6ZXIncyBzZW5zaXRpdml0eVxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluIG1pbmltdW0gZGVjaWJlbHMgdmFsdWVcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heCBtYXhpbXVtIGRlY2liZWxzIHZhbHVlXG5cdCAqL1xuXHRzZXRTZW5zaXRpdml0eSggbWluLCBtYXggKSB7XG5cdFx0Zm9yICggY29uc3QgaSBvZiBbMCwxXSApIHtcblx0XHRcdHRoaXMuX2FuYWx5emVyWyBpIF0ubWluRGVjaWJlbHMgPSBNYXRoLm1pbiggbWluLCBtYXggKTtcblx0XHRcdHRoaXMuX2FuYWx5emVyWyBpIF0ubWF4RGVjaWJlbHMgPSBNYXRoLm1heCggbWluLCBtYXggKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogU3RhcnQgLyBzdG9wIGNhbnZhcyBhbmltYXRpb25cblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBbdmFsdWVdIGlmIHVuZGVmaW5lZCwgaW52ZXJ0cyB0aGUgY3VycmVudCBzdGF0dXNcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHJlc3VsdGluZyBzdGF0dXMgYWZ0ZXIgdGhlIGNoYW5nZVxuXHQgKi9cblx0dG9nZ2xlQW5hbHl6ZXIoIHZhbHVlICkge1xuXHRcdGNvbnN0IHN0YXJ0ZWQgPSB0aGlzLmlzT247XG5cblx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKVxuXHRcdFx0dmFsdWUgPSAhIHN0YXJ0ZWQ7XG5cblx0XHRpZiAoIHN0YXJ0ZWQgJiYgISB2YWx1ZSApIHtcblx0XHRcdGNhbmNlbEFuaW1hdGlvbkZyYW1lKCB0aGlzLl9ydW5JZCApO1xuXHRcdFx0dGhpcy5fcnVuSWQgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKCAhIHN0YXJ0ZWQgJiYgdmFsdWUgKSB7XG5cdFx0XHR0aGlzLl9mcmFtZSA9IHRoaXMuX2ZwcyA9IDA7XG5cdFx0XHR0aGlzLl90aW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cdFx0XHR0aGlzLl9ydW5JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSggdGltZXN0YW1wID0+IHRoaXMuX2RyYXcoIHRpbWVzdGFtcCApICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuaXNPbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBUb2dnbGVzIGNhbnZhcyBmdWxsLXNjcmVlbiBtb2RlXG5cdCAqL1xuXHR0b2dnbGVGdWxsc2NyZWVuKCkge1xuXHRcdGlmICggdGhpcy5pc0Z1bGxzY3JlZW4gKSB7XG5cdFx0XHRpZiAoIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuIClcblx0XHRcdFx0ZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTtcblx0XHRcdGVsc2UgaWYgKCBkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbiApXG5cdFx0XHRcdGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Y29uc3QgZnNFbCA9IHRoaXMuX2ZzRWw7XG5cdFx0XHRpZiAoIGZzRWwucmVxdWVzdEZ1bGxzY3JlZW4gKVxuXHRcdFx0XHRmc0VsLnJlcXVlc3RGdWxsc2NyZWVuKCk7XG5cdFx0XHRlbHNlIGlmICggZnNFbC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbiApXG5cdFx0XHRcdGZzRWwud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblx0ICpcblx0ICogUFJJVkFURSBNRVRIT0RTXG5cdCAqXG5cdCAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBDYWxjdWxhdGUgYXV4aWxpYXJ5IHZhbHVlcyBhbmQgZmxhZ3Ncblx0ICovXG5cdF9jYWxjQXV4KCkge1xuXHRcdGNvbnN0IGNhbnZhcyAgID0gdGhpcy5jYW52YXMsXG5cdFx0XHQgIGlzUmFkaWFsID0gdGhpcy5fcmFkaWFsLFxuXHRcdFx0ICBpc0R1YWwgICA9IHRoaXMuX3N0ZXJlbyAmJiAhIGlzUmFkaWFsLFxuXHRcdFx0ICBjZW50ZXJYICA9IGNhbnZhcy53aWR0aCA+PiAxO1xuXG5cdFx0dGhpcy5fcmFkaXVzICAgICAgICAgPSBNYXRoLm1pbiggY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICkgKiAoIHRoaXMuX3N0ZXJlbyA/IC4zNzUgOiAuMTI1ICkgfCAwO1xuXHRcdHRoaXMuX2JhclNwYWNlUHggICAgID0gTWF0aC5taW4oIHRoaXMuX2JhcldpZHRoIC0gMSwgKCB0aGlzLl9iYXJTcGFjZSA+IDAgJiYgdGhpcy5fYmFyU3BhY2UgPCAxICkgPyB0aGlzLl9iYXJXaWR0aCAqIHRoaXMuX2JhclNwYWNlIDogdGhpcy5fYmFyU3BhY2UgKTtcblx0XHR0aGlzLl9pc09jdGF2ZUJhbmRzICA9IHRoaXMuX21vZGUgJSAxMCAhPSAwO1xuXHRcdHRoaXMuX2lzTGVkRGlzcGxheSAgID0gdGhpcy5fc2hvd0xlZHMgJiYgdGhpcy5faXNPY3RhdmVCYW5kcyAmJiAhIGlzUmFkaWFsO1xuXHRcdHRoaXMuX2lzTHVtaUJhcnMgICAgID0gdGhpcy5fbHVtaUJhcnMgJiYgdGhpcy5faXNPY3RhdmVCYW5kcyAmJiAhIGlzUmFkaWFsO1xuXHRcdHRoaXMuX2lzQWxwaGFCYXJzICAgID0gdGhpcy5fYWxwaGFCYXJzICYmICEgdGhpcy5faXNMdW1pQmFycyAmJiB0aGlzLl9tb2RlICE9IDEwO1xuXHRcdHRoaXMuX2lzT3V0bGluZSAgICAgID0gdGhpcy5fb3V0bGluZUJhcnMgJiYgdGhpcy5faXNPY3RhdmVCYW5kcyAmJiAhIHRoaXMuX2lzTHVtaUJhcnMgJiYgISB0aGlzLl9pc0xlZERpc3BsYXk7XG5cdFx0dGhpcy5fbWF4aW1pemVMZWRzICAgPSAhIHRoaXMuX3N0ZXJlbyB8fCB0aGlzLl9yZWZsZXhSYXRpbyA+IDAgJiYgISB0aGlzLl9pc0x1bWlCYXJzO1xuXG5cdFx0dGhpcy5fY2hhbm5lbEhlaWdodCAgPSBjYW52YXMuaGVpZ2h0IC0gKCBpc0R1YWwgJiYgISB0aGlzLl9pc0xlZERpc3BsYXkgPyAuNSA6IDAgKSA+PiBpc0R1YWw7XG5cdFx0dGhpcy5fYW5hbHl6ZXJIZWlnaHQgPSB0aGlzLl9jaGFubmVsSGVpZ2h0ICogKCB0aGlzLl9pc0x1bWlCYXJzIHx8IGlzUmFkaWFsID8gMSA6IDEgLSB0aGlzLl9yZWZsZXhSYXRpbyApIHwgMDtcblxuXHRcdC8vIGNoYW5uZWxHYXAgaXMgKiowKiogaWYgaXNMZWREaXNwbGF5ID09IHRydWUgKExFRHMgYWxyZWFkeSBoYXZlIHNwYWNpbmcpOyAqKjEqKiBpZiBjYW52YXMgaGVpZ2h0IGlzIG9kZCAod2luZG93ZWQpOyAqKjIqKiBpZiBpdCdzIGV2ZW5cblx0XHQvLyBUT0RPOiBpbXByb3ZlIHRoaXMsIG1ha2UgaXQgY29uZmlndXJhYmxlP1xuXHRcdHRoaXMuX2NoYW5uZWxHYXAgICAgID0gaXNEdWFsID8gY2FudmFzLmhlaWdodCAtIHRoaXMuX2NoYW5uZWxIZWlnaHQgKiAyIDogMDtcblxuXHRcdHRoaXMuX2FuYWx5emVyV2lkdGggID0gY2FudmFzLndpZHRoIC0gY2VudGVyWCAqICggdGhpcy5fbWlycm9yICE9IDAgKTtcblx0XHR0aGlzLl9pbml0aWFsWCAgICAgICA9IGNlbnRlclggKiAoIHRoaXMuX21pcnJvciA9PSAtMSAmJiAhIGlzUmFkaWFsICk7XG5cdH1cblxuXHQvKipcblx0ICogUHJlY2FsY3VsYXRlIHRoZSBhY3R1YWwgWC1jb29yZGluYXRlIG9uIHNjcmVlbiBmb3IgZWFjaCBhbmFseXplciBiYXJcblx0ICovXG5cdF9jYWxjQmFycygpIHtcblx0XHQvKlxuXHQgXHQgICBTaW5jZSB0aGUgZnJlcXVlbmN5IHNjYWxlIGlzIGxvZ2FyaXRobWljLCBlYWNoIHBvc2l0aW9uIGluIHRoZSBYLWF4aXMgYWN0dWFsbHkgcmVwcmVzZW50cyBhIHBvd2VyIG9mIDEwLlxuXHQgXHQgICBUbyBpbXByb3ZlIHBlcmZvcm1hY2UsIHRoZSBwb3NpdGlvbiBvZiBlYWNoIGZyZXF1ZW5jeSBpcyBjYWxjdWxhdGVkIGluIGFkdmFuY2UgYW5kIHN0b3JlZCBpbiBhbiBhcnJheS5cblx0IFx0ICAgQ2FudmFzIHNwYWNlIHVzYWdlIGlzIG9wdGltaXplZCB0byBhY2NvbW1vZGF0ZSBleGFjdGx5IHRoZSBmcmVxdWVuY3kgcmFuZ2UgdGhlIHVzZXIgbmVlZHMuXG5cdCBcdCAgIFBvc2l0aW9ucyBuZWVkIHRvIGJlIHJlY2FsY3VsYXRlZCB3aGVuZXZlciB0aGUgZnJlcXVlbmN5IHJhbmdlLCBGRlQgc2l6ZSBvciBjYW52YXMgc2l6ZSBjaGFuZ2UuXG5cblx0IFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gY2FudmFzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuXHQgXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cdCBcdCAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tfC0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLSEtLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLXwtLS0tLS0tLS0tLS18XG5cdCBcdCAgICAgIDEgICAgICAgICAgICAgICAgICAxMCAgICAgfCAgICAgICAgICAgIDEwMCAgICAgICAgICAgICAgICAgIDFLICAgICAgICAgICAgICAgICAxMEsgICAgIHwgICAgICAgICAgIDEwMEsgKEh6KVxuXHQgXHQgICAoMTBeMCkgICAgICAgICAgICAgICgxMF4xKSAgIHwgICAgICAgICAgKDEwXjIpICAgICAgICAgICAgICAgKDEwXjMpICAgICAgICAgICAgICAoMTBeNCkgICB8ICAgICAgICAgICgxMF41KVxuXHQgXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwtLS0tLS0tLS0tLS0tfDwtLS0gbG9nV2lkdGggLS0tLT58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG5cdCBcdCAgICAgICAgICAgICAgICAgICAgbWluRnJlcS0tPiAyMCAgICAgICAgICAgICAgICAgICAocGl4ZWxzKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMjJLIDwtLW1heEZyZXFcblx0IFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICgxMF4xLjMpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoMTBeNC4zNClcblx0IFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5Mb2dcblx0IFx0Ki9cblxuXHRcdGNvbnN0IGJhcnMgPSB0aGlzLl9iYXJzID0gW107IC8vIGluaXRpYWxpemUgb2JqZWN0IHByb3BlcnR5XG5cblx0XHRpZiAoICEgdGhpcy5fcmVhZHkgKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0Ly8gaGVscGVyIGZ1bmN0aW9uc1xuXHRcdGNvbnN0IGJpblRvRnJlcSA9IGJpbiA9PiBiaW4gKiB0aGlzLmF1ZGlvQ3R4LnNhbXBsZVJhdGUgLyB0aGlzLmZmdFNpemUgfHwgMTsgLy8gcmV0dXJucyAxIGZvciBiaW4gMFxuXHRcdGNvbnN0IGJhcnNQdXNoICA9ICggcG9zWCwgYmluTG8sIGJpbkhpLCBmcmVxTG8sIGZyZXFIaSwgcmF0aW9MbywgcmF0aW9IaSApID0+IGJhcnMucHVzaCggeyBwb3NYLCBiaW5MbywgYmluSGksIGZyZXFMbywgZnJlcUhpLCByYXRpb0xvLCByYXRpb0hpLCBwZWFrOiBbMCwwXSwgaG9sZDogWzBdLCB2YWx1ZTogWzBdIH0gKTtcblxuXHRcdGNvbnN0IGFuYWx5emVyV2lkdGggPSB0aGlzLl9hbmFseXplcldpZHRoLFxuXHRcdFx0ICBpbml0aWFsWCAgICAgID0gdGhpcy5faW5pdGlhbFgsXG5cdFx0XHQgIG1heEZyZXEgICAgICAgPSB0aGlzLl9tYXhGcmVxLFxuXHRcdFx0ICBtaW5GcmVxICAgICAgID0gdGhpcy5fbWluRnJlcTtcblxuXHRcdGxldCBtaW5Mb2csXHRsb2dXaWR0aDtcblxuXHRcdGlmICggdGhpcy5faXNPY3RhdmVCYW5kcyApIHtcblxuXHRcdFx0Ly8gZ2VuZXJhdGUgYSAxMS1vY3RhdmUgMjQtdG9uZSBlcXVhbCB0ZW1wZXJlZCBzY2FsZSAoMTZIeiB0byAzM2tIeilcblxuXHRcdFx0Lypcblx0XHRcdFx0QSBzaW1wbGUgbGluZWFyIGludGVycG9sYXRpb24gaXMgdXNlZCB0byBvYnRhaW4gYW4gYXBwcm94aW1hdGUgYW1wbGl0dWRlIHZhbHVlIGZvciB0aGUgZGVzaXJlZCBmcmVxdWVuY3lcblx0XHRcdFx0ZnJvbSBhdmFpbGFibGUgRkZUIGRhdGEsIGxpa2Ugc286XG5cblx0XHRcdFx0aCA9IGhMbyArICggaEhpIC0gaExvICkgKiAoIGYgLSBmTG8gKSAvICggZkhpIC0gZkxvIClcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIFxcX19fX19fX19fX19fX19fX19fX19fX19fX19fL1xuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG5cdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRpb1xuXHRcdFx0XHR3aGVyZTpcblxuXHRcdFx0XHRmICAgLSBkZXNpcmVkIGZyZXF1ZW5jeVxuXHRcdFx0XHRoICAgLSBhbXBsaXR1ZGUgb2YgZGVzaXJlZCBmcmVxdWVuY3lcblx0XHRcdFx0ZkxvIC0gZnJlcXVlbmN5IHJlcHJlc2VudGVkIGJ5IHRoZSBsb3dlciBGRlQgYmluXG5cdFx0XHRcdGZIaSAtIGZyZXF1ZW5jeSByZXByZXNlbnRlZCBieSB0aGUgaGlnaGVyIEZGVCBiaW5cblx0XHRcdFx0aExvIC0gYW1wbGl0dWRlIG9mIGZMb1xuXHRcdFx0XHRoSGkgLSBhbXBsaXR1ZGUgb2YgZkhpXG5cblx0XHRcdFx0cmF0aW8gaXMgY2FsY3VsYXRlZCBpbiBhZHZhbmNlIGhlcmUsIHRvIHJlZHVjZSBjb21wdXRhdGlvbmFsIGNvbXBsZXhpdHkgZHVyaW5nIHJlYWwtdGltZSByZW5kZXJpbmcgaW4gdGhlIF9kcmF3KCkgZnVuY3Rpb25cblx0XHRcdCovXG5cblx0XHRcdGxldCB0ZW1wZXJlZFNjYWxlID0gW107XG5cblx0XHRcdGZvciAoIGxldCBvY3RhdmUgPSAwOyBvY3RhdmUgPCAxMTsgb2N0YXZlKysgKSB7XG5cdFx0XHRcdGZvciAoIGxldCBub3RlID0gMDsgbm90ZSA8IDI0OyBub3RlKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBmcmVxICAgICA9IEMwICogUk9PVDI0ICoqICggb2N0YXZlICogMjQgKyBub3RlICksXG5cdFx0XHRcdFx0XHQgIGJpbiAgICAgID0gdGhpcy5fZnJlcVRvQmluKCBmcmVxLCAnZmxvb3InICksXG5cdFx0XHRcdFx0XHQgIGJpbkZyZXEgID0gYmluVG9GcmVxKCBiaW4gKSxcblx0XHRcdFx0XHRcdCAgbmV4dEZyZXEgPSBiaW5Ub0ZyZXEoIGJpbiArIDEgKSxcblx0XHRcdFx0XHRcdCAgcmF0aW8gICAgPSAoIGZyZXEgLSBiaW5GcmVxICkgLyAoIG5leHRGcmVxIC0gYmluRnJlcSApO1xuXG5cdFx0XHRcdFx0dGVtcGVyZWRTY2FsZS5wdXNoKCB7IGZyZXEsIGJpbiwgcmF0aW8gfSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGdlbmVyYXRlIHRoZSBmcmVxdWVuY3kgYmFuZHMgYWNjb3JkaW5nIHRvIGN1cnJlbnQgYW5hbHl6ZXIgc2V0dGluZ3NcblxuXHRcdFx0Y29uc3Qgc3RlcHMgPSBbMCwxLDIsMyw0LDYsOCwxMiwyNF1bIHRoaXMuX21vZGUgXTsgLy8gbnVtYmVyIG9mIG5vdGVzIGdyb3VwZWQgcGVyIGJhbmQgZm9yIGVhY2ggbW9kZVxuXG5cdFx0XHRmb3IgKCBsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRlbXBlcmVkU2NhbGUubGVuZ3RoOyBpbmRleCArPSBzdGVwcyApIHtcblx0XHRcdFx0bGV0IHsgZnJlcTogZnJlcUxvLCBiaW46IGJpbkxvLCByYXRpbzogcmF0aW9MbyB9ID0gdGVtcGVyZWRTY2FsZVsgaW5kZXggXSwgICAgICAgICAgICAgLy8gYmFuZCBzdGFydFxuXHRcdFx0XHRcdHsgZnJlcTogZnJlcUhpLCBiaW46IGJpbkhpLCByYXRpbzogcmF0aW9IaSB9ID0gdGVtcGVyZWRTY2FsZVsgaW5kZXggKyBzdGVwcyAtIDEgXTsgLy8gYmFuZCBlbmRcblxuXHRcdFx0XHRjb25zdCBuQmFycyAgID0gYmFycy5sZW5ndGgsXG5cdFx0XHRcdFx0ICBwcmV2QmFyID0gYmFyc1sgbkJhcnMgLSAxIF07XG5cblx0XHRcdFx0Ly8gaWYgdGhlIGVuZGluZyBmcmVxdWVuY3kgaXMgb3V0IG9mIHJhbmdlLCB3ZSdyZSBkb25lIGhlcmVcblx0XHRcdFx0aWYgKCBmcmVxSGkgPiBtYXhGcmVxIHx8IGJpbkhpID49IHRoaXMuZmZ0U2l6ZSAvIDIgKSB7XG5cdFx0XHRcdFx0cHJldkJhci5iaW5IaSsrOyAgICAgLy8gYWRkIGFuIGV4dHJhIGJpbiB0byB0aGUgbGFzdCBiYXIsIHRvIGZ1bGx5IGluY2x1ZGUgdGhlIGxhc3QgdmFsaWQgYmFuZFxuXHRcdFx0XHRcdHByZXZCYXIucmF0aW9IaSA9IDA7IC8vIGRpc2FibGUgaW50ZXJwb2xhdGlvblxuXHRcdFx0XHRcdHByZXZCYXIuZnJlcUhpID0gYmluVG9GcmVxKCBwcmV2QmFyLmJpbkhpICk7IC8vIHVwZGF0ZSBlbmRpbmcgZnJlcXVlbmN5XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpcyB0aGUgc3RhcnRpbmcgZnJlcXVlbmN5IGluIHRoZSBzZWxlY3RlZCByYW5nZT9cblx0XHRcdFx0aWYgKCBmcmVxTG8gPj0gbWluRnJlcSApIHtcblx0XHRcdFx0XHRpZiAoIG5CYXJzID4gMCApIHtcblx0XHRcdFx0XHRcdGNvbnN0IGRpZmYgPSBiaW5MbyAtIHByZXZCYXIuYmluSGk7XG5cblx0XHRcdFx0XHRcdC8vIGNoZWNrIGlmIHdlIHNraXBwZWQgYW55IGF2YWlsYWJsZSBGRlQgYmlucyBzaW5jZSB0aGUgbGFzdCBiYXJcblx0XHRcdFx0XHRcdGlmICggZGlmZiA+IDEgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGFsbG9jYXRlIGhhbGYgb2YgdGhlIHVudXNlZCBiaW5zIHRvIHRoZSBwcmV2aW91cyBiYXJcblx0XHRcdFx0XHRcdFx0cHJldkJhci5iaW5IaSA9IGJpbkxvIC0gKCBkaWZmID4+IDEgKTtcblx0XHRcdFx0XHRcdFx0cHJldkJhci5yYXRpb0hpID0gMDtcblx0XHRcdFx0XHRcdFx0cHJldkJhci5mcmVxSGkgPSBiaW5Ub0ZyZXEoIHByZXZCYXIuYmluSGkgKTsgLy8gdXBkYXRlIGVuZGluZyBmcmVxdWVuY3lcblxuXHRcdFx0XHRcdFx0XHQvLyBpZiB0aGUgcHJldmlvdXMgYmFyIGRvZXNuJ3Qgc2hhcmUgYW55IGJpbnMgd2l0aCBvdGhlciBiYXJzLCBubyBuZWVkIGZvciBpbnRlcnBvbGF0aW9uXG5cdFx0XHRcdFx0XHRcdGlmICggbkJhcnMgPiAxICYmIHByZXZCYXIuYmluSGkgPiBwcmV2QmFyLmJpbkxvICYmIHByZXZCYXIuYmluTG8gPiBiYXJzWyBuQmFycyAtIDIgXS5iaW5IaSApIHtcblx0XHRcdFx0XHRcdFx0XHRwcmV2QmFyLnJhdGlvTG8gPSAwO1xuXHRcdFx0XHRcdFx0XHRcdHByZXZCYXIuZnJlcUxvID0gYmluVG9GcmVxKCBwcmV2QmFyLmJpbkxvICk7IC8vIHVwZGF0ZSBzdGFydGluZyBmcmVxdWVuY3lcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHN0YXJ0IHRoZSBjdXJyZW50IGJhciBhdCB0aGUgYmluIGZvbGxvd2luZyB0aGUgbGFzdCBhbGxvY2F0ZWQgYmluXG5cdFx0XHRcdFx0XHRcdGJpbkxvID0gcHJldkJhci5iaW5IaSArIDE7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGlmIHRoZSBsb3dlciBiaW4gaXMgbm90IHNoYXJlZCB3aXRoIHRoZSBlbmRpbmcgZnJlcXVlbmN5IG5vciB0aGUgcHJldmlvdXMgYmFyLCBubyBuZWVkIHRvIGludGVycG9sYXRlIGl0XG5cdFx0XHRcdFx0XHRpZiAoIGJpbkhpID4gYmluTG8gJiYgYmluTG8gPiBwcmV2QmFyLmJpbkhpICkge1xuXHRcdFx0XHRcdFx0XHRyYXRpb0xvID0gMDtcblx0XHRcdFx0XHRcdFx0ZnJlcUxvID0gYmluVG9GcmVxKCBiaW5MbyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJhcnNQdXNoKCAwLCBiaW5MbywgYmluSGksIGZyZXFMbywgZnJlcUhpLCByYXRpb0xvLCByYXRpb0hpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fYmFyV2lkdGggPSBhbmFseXplcldpZHRoIC8gYmFycy5sZW5ndGg7XG5cblx0XHRcdGJhcnMuZm9yRWFjaCggKCBiYXIsIGluZGV4ICkgPT4gYmFyLnBvc1ggPSBpbml0aWFsWCArIGluZGV4ICogdGhpcy5fYmFyV2lkdGggKTtcblxuXHRcdFx0bWluTG9nID0gTWF0aC5sb2cxMCggYmFyc1swXS5mcmVxTG8gKTtcblx0XHRcdGxvZ1dpZHRoID0gYW5hbHl6ZXJXaWR0aCAvICggTWF0aC5sb2cxMCggYmFyc1sgYmFycy5sZW5ndGggLSAxIF0uZnJlcUhpICkgLSBtaW5Mb2cgKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cblx0XHRcdC8vIERpc2NyZXRlIGZyZXF1ZW5jaWVzIG1vZGVzXG5cblx0XHRcdHRoaXMuX2JhcldpZHRoID0gMTtcblxuXHRcdFx0bWluTG9nID0gTWF0aC5sb2cxMCggbWluRnJlcSApO1xuXHRcdFx0bG9nV2lkdGggPSBhbmFseXplcldpZHRoIC8gKCBNYXRoLmxvZzEwKCBtYXhGcmVxICkgLSBtaW5Mb2cgKTtcblxuXHRcdFx0Y29uc3QgbWluSW5kZXggPSB0aGlzLl9mcmVxVG9CaW4oIG1pbkZyZXEsICdmbG9vcicgKSxcblx0XHRcdFx0ICBtYXhJbmRleCA9IHRoaXMuX2ZyZXFUb0JpbiggbWF4RnJlcSApO1xuXG5cdCBcdFx0bGV0IGxhc3RQb3MgPSAtOTk5O1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IG1pbkluZGV4OyBpIDw9IG1heEluZGV4OyBpKysgKSB7XG5cdFx0XHRcdGNvbnN0IGZyZXEgPSBiaW5Ub0ZyZXEoIGkgKSwgLy8gZnJlcXVlbmN5IHJlcHJlc2VudGVkIGJ5IHRoaXMgaW5kZXhcblx0XHRcdFx0XHQgIHBvcyAgPSBpbml0aWFsWCArIE1hdGgucm91bmQoIGxvZ1dpZHRoICogKCBNYXRoLmxvZzEwKCBmcmVxICkgLSBtaW5Mb2cgKSApOyAvLyBhdm9pZCBmcmFjdGlvbmFyeSBwaXhlbCB2YWx1ZXNcblxuXHRcdFx0XHQvLyBpZiBpdCdzIG9uIGEgZGlmZmVyZW50IFgtY29vcmRpbmF0ZSwgY3JlYXRlIGEgbmV3IGJhciBmb3IgdGhpcyBmcmVxdWVuY3lcblx0XHRcdFx0aWYgKCBwb3MgPiBsYXN0UG9zICkge1xuXHRcdFx0XHRcdGJhcnNQdXNoKCBwb3MsIGksIGksIGZyZXEsIGZyZXEsIDAsIDAgKTtcblx0XHRcdFx0XHRsYXN0UG9zID0gcG9zO1xuXHRcdFx0XHR9IC8vIG90aGVyd2lzZSwgYWRkIHRoaXMgZnJlcXVlbmN5IHRvIHRoZSBsYXN0IGJhcidzIHJhbmdlXG5cdFx0XHRcdGVsc2UgaWYgKCBiYXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRiYXJzWyBiYXJzLmxlbmd0aCAtIDEgXS5iaW5IaSA9IGk7XG5cdFx0XHRcdFx0YmFyc1sgYmFycy5sZW5ndGggLSAxIF0uZnJlcUhpID0gZnJlcTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHNhdmUgdGhlc2UgZm9yIHNjYWxlIGdlbmVyYXRpb25cblx0XHR0aGlzLl9taW5Mb2cgPSBtaW5Mb2c7XG5cdFx0dGhpcy5fbG9nV2lkdGggPSBsb2dXaWR0aDtcblxuXHRcdC8vIHVwZGF0ZSBpbnRlcm5hbCB2YXJpYWJsZXNcblx0XHR0aGlzLl9jYWxjQXV4KCk7XG5cblx0XHQvLyBnZW5lcmF0ZSB0aGUgWC1heGlzIGFuZCByYWRpYWwgc2NhbGVzXG5cdFx0dGhpcy5fY3JlYXRlU2NhbGVzKCk7XG5cblx0XHQvLyB1cGRhdGUgTEVEIHByb3BlcnRpZXNcblx0XHR0aGlzLl9jYWxjTGVkcygpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENhbGN1bGF0ZSBhdHRyaWJ1dGVzIGZvciB0aGUgdmludGFnZSBMRURzIGVmZmVjdCwgYmFzZWQgb24gdmlzdWFsaXphdGlvbiBtb2RlIGFuZCBjYW52YXMgcmVzb2x1dGlvblxuXHQgKi9cblx0X2NhbGNMZWRzKCkge1xuXHRcdGlmICggISB0aGlzLl9pc09jdGF2ZUJhbmRzIHx8ICEgdGhpcy5fcmVhZHkgKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0Ly8gYWRqdXN0bWVudCBmb3IgaGlnaCBwaXhlbC1yYXRpbyB2YWx1ZXMgb24gbG93LXJlc29sdXRpb24gc2NyZWVucyAoQW5kcm9pZCBUVilcblx0XHRjb25zdCBkUFIgPSB0aGlzLl9waXhlbFJhdGlvIC8gKCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDEgJiYgd2luZG93LnNjcmVlbi5oZWlnaHQgPD0gNTQwID8gMiA6IDEgKTtcblxuXHRcdGNvbnN0IHBhcmFtcyA9IFsgW10sXG5cdFx0XHRbIDEyOCwgIDMsIC40NSAgXSwgLy8gbW9kZSAxXG5cdFx0XHRbIDEyOCwgIDQsIC4yMjUgXSwgLy8gbW9kZSAyXG5cdFx0XHRbICA5NiwgIDYsIC4yMjUgXSwgLy8gbW9kZSAzXG5cdFx0XHRbICA4MCwgIDYsIC4yMjUgXSwgLy8gbW9kZSA0XG5cdFx0XHRbICA4MCwgIDYsIC4xMjUgXSwgLy8gbW9kZSA1XG5cdFx0XHRbICA2NCwgIDYsIC4xMjUgXSwgLy8gbW9kZSA2XG5cdFx0XHRbICA0OCwgIDgsIC4xMjUgXSwgLy8gbW9kZSA3XG5cdFx0XHRbICAyNCwgMTYsIC4xMjUgXSwgLy8gbW9kZSA4XG5cdFx0XTtcblxuXHRcdC8vIHVzZSBjdXN0b20gTEVEIHBhcmFtZXRlcnMgaWYgc2V0LCBvciB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzIGZvciB0aGUgY3VycmVudCBtb2RlXG5cdFx0Y29uc3QgY3VzdG9tUGFyYW1zID0gdGhpcy5fbGVkUGFyYW1zLFxuXHRcdFx0ICBbIG1heExlZHMsIHNwYWNlVlJhdGlvLCBzcGFjZUhSYXRpbyBdID0gY3VzdG9tUGFyYW1zIHx8IHBhcmFtc1sgdGhpcy5fbW9kZSBdO1xuXG5cdFx0bGV0IGxlZENvdW50LCBzcGFjZVYsXG5cdFx0XHRhbmFseXplckhlaWdodCA9IHRoaXMuX2FuYWx5emVySGVpZ2h0O1xuXG5cdFx0aWYgKCBjdXN0b21QYXJhbXMgKSB7XG5cdFx0XHRjb25zdCBtaW5IZWlnaHQgPSAyICogZFBSO1xuXHRcdFx0bGV0IGJsb2NrSGVpZ2h0O1xuXHRcdFx0bGVkQ291bnQgPSBtYXhMZWRzICsgMTtcblx0XHRcdGRvIHtcblx0XHRcdFx0bGVkQ291bnQtLTtcblx0XHRcdFx0YmxvY2tIZWlnaHQgPSBhbmFseXplckhlaWdodCAvIGxlZENvdW50IC8gKCAxICsgc3BhY2VWUmF0aW8gKTtcblx0XHRcdFx0c3BhY2VWID0gYmxvY2tIZWlnaHQgKiBzcGFjZVZSYXRpbztcblx0XHRcdH0gd2hpbGUgKCAoIGJsb2NrSGVpZ2h0IDwgbWluSGVpZ2h0IHx8IHNwYWNlViA8IG1pbkhlaWdodCApICYmIGxlZENvdW50ID4gMSApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdC8vIGNhbGN1bGF0ZSB2ZXJ0aWNhbCBzcGFjaW5nIC0gYWltIGZvciB0aGUgcmVmZXJlbmNlIHJhdGlvLCBidXQgbWFrZSBzdXJlIGl0J3MgYXQgbGVhc3QgMnB4XG5cdFx0XHRjb25zdCByZWZSYXRpbyA9IDU0MCAvIHNwYWNlVlJhdGlvO1xuXHRcdFx0c3BhY2VWID0gTWF0aC5taW4oIHNwYWNlVlJhdGlvICogZFBSLCBNYXRoLm1heCggMiwgYW5hbHl6ZXJIZWlnaHQgLyByZWZSYXRpbyArIC4xIHwgMCApICk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVtb3ZlIHRoZSBleHRyYSBzcGFjaW5nIGJlbG93IHRoZSBsYXN0IGxpbmUgb2YgTEVEc1xuXHRcdGlmICggdGhpcy5fbWF4aW1pemVMZWRzIClcblx0XHRcdGFuYWx5emVySGVpZ2h0ICs9IHNwYWNlVjtcblxuXHRcdC8vIHJlY2FsY3VsYXRlIHRoZSBudW1iZXIgb2YgbGVkcywgY29uc2lkZXJpbmcgdGhlIGVmZmVjdGl2ZSBzcGFjZVZcblx0XHRpZiAoICEgY3VzdG9tUGFyYW1zIClcblx0XHRcdGxlZENvdW50ID0gTWF0aC5taW4oIG1heExlZHMsIGFuYWx5emVySGVpZ2h0IC8gKCBzcGFjZVYgKiAyICkgfCAwICk7XG5cblx0XHR0aGlzLl9sZWRzID0gW1xuXHRcdFx0bGVkQ291bnQsXG5cdFx0XHRzcGFjZUhSYXRpbyA+PSAxID8gc3BhY2VIUmF0aW8gOiB0aGlzLl9iYXJXaWR0aCAqIHNwYWNlSFJhdGlvLCAvLyBzcGFjZUhcblx0XHRcdHNwYWNlVixcblx0XHRcdGFuYWx5emVySGVpZ2h0IC8gbGVkQ291bnQgLSBzcGFjZVYgLy8gbGVkSGVpZ2h0XG5cdFx0XTtcblx0fVxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSB0aGUgWC1heGlzIGFuZCByYWRpYWwgc2NhbGVzIGluIGF1eGlsaWFyeSBjYW52YXNlc1xuXHQgKi9cblx0X2NyZWF0ZVNjYWxlcygpIHtcblx0XHRjb25zdCBmcmVxTGFiZWxzICA9IFsgMTYsIDMxLCA2MywgMTI1LCAyNTAsIDUwMCwgMTAwMCwgMjAwMCwgNDAwMCwgODAwMCwgMTYwMDAgXSxcblx0XHRcdCAgY2FudmFzICAgICAgPSB0aGlzLl9jYW52YXNDdHguY2FudmFzLFxuXHRcdFx0ICBzY2FsZVggICAgICA9IHRoaXMuX3NjYWxlWCxcblx0XHRcdCAgc2NhbGVSICAgICAgPSB0aGlzLl9zY2FsZVIsXG5cdFx0XHQgIGNhbnZhc1ggICAgID0gc2NhbGVYLmNhbnZhcyxcblx0XHRcdCAgY2FudmFzUiAgICAgPSBzY2FsZVIuY2FudmFzLFxuXHRcdFx0ICBzY2FsZUhlaWdodCA9IE1hdGgubWluKCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQgKSAqIC4wMyB8IDA7IC8vIGNpcmN1bGFyIHNjYWxlIGhlaWdodCAocmFkaWFsIG1vZGUpXG5cblx0XHQvLyBpbiByYWRpYWwgc3RlcmVvIG1vZGUsIHRoZSBzY2FsZSBpcyBwb3NpdGlvbmVkIGV4YWN0bHkgYmV0d2VlbiBib3RoIGNoYW5uZWxzLCBieSBtYWtpbmcgdGhlIGNhbnZhcyBhIGJpdCBsYXJnZXIgdGhhbiB0aGUgY2VudHJhbCBkaWFtZXRlclxuXHRcdGNhbnZhc1Iud2lkdGggPSBjYW52YXNSLmhlaWdodCA9ICggdGhpcy5fcmFkaXVzIDw8IDEgKSArICggdGhpcy5fc3RlcmVvICogc2NhbGVIZWlnaHQgKTtcblxuXHRcdGNvbnN0IHJhZGl1cyAgPSBjYW52YXNSLndpZHRoID4+IDEsIC8vIHRoaXMgaXMgYWxzbyB1c2VkIGFzIHRoZSBjZW50ZXIgWCBhbmQgWSBjb29yZGluYXRlcyBvZiB0aGUgY2lyY3VsYXIgc2NhbGUgY2FudmFzXG5cdFx0XHQgIHJhZGlhbFkgPSByYWRpdXMgLSBzY2FsZUhlaWdodCAqIC43O1x0Ly8gdmVydGljYWwgcG9zaXRpb24gb2YgdGV4dCBsYWJlbHMgaW4gdGhlIGNpcmN1bGFyIHNjYWxlXG5cblx0XHQvLyBoZWxwZXIgZnVuY3Rpb25cblx0XHRjb25zdCByYWRpYWxMYWJlbCA9ICggeCwgbGFiZWwgKSA9PiB7XG5cdFx0XHRjb25zdCBhbmdsZSAgPSBUQVUgKiAoIHggLyBjYW52YXMud2lkdGggKSxcblx0XHRcdFx0ICBhZGpBbmcgPSBhbmdsZSAtIEhBTEZfUEksIC8vIHJvdGF0ZSBhbmdsZXMgc28gMCBpcyBhdCB0aGUgdG9wXG5cdFx0XHRcdCAgcG9zWCAgID0gcmFkaWFsWSAqIE1hdGguY29zKCBhZGpBbmcgKSxcblx0XHRcdFx0ICBwb3NZICAgPSByYWRpYWxZICogTWF0aC5zaW4oIGFkakFuZyApO1xuXG5cdFx0XHRzY2FsZVIuc2F2ZSgpO1xuXHRcdFx0c2NhbGVSLnRyYW5zbGF0ZSggcmFkaXVzICsgcG9zWCwgcmFkaXVzICsgcG9zWSApO1xuXHRcdFx0c2NhbGVSLnJvdGF0ZSggYW5nbGUgKTtcblx0XHRcdHNjYWxlUi5maWxsVGV4dCggbGFiZWwsIDAsIDAgKTtcblx0XHRcdHNjYWxlUi5yZXN0b3JlKCk7XG5cdFx0fVxuXG5cdFx0Ly8gY2xlYXIgc2NhbGUgY2FudmFzXG5cdFx0Y2FudmFzWC53aWR0aCB8PSAwO1xuXG5cdFx0c2NhbGVYLmZpbGxTdHlsZSA9IHNjYWxlUi5zdHJva2VTdHlsZSA9ICcjMDAwYyc7XG5cdFx0c2NhbGVYLmZpbGxSZWN0KCAwLCAwLCBjYW52YXNYLndpZHRoLCBjYW52YXNYLmhlaWdodCApO1xuXG5cdFx0c2NhbGVSLmFyYyggcmFkaXVzLCByYWRpdXMsIHJhZGl1cyAtIHNjYWxlSGVpZ2h0IC8gMiwgMCwgVEFVICk7XG5cdFx0c2NhbGVSLmxpbmVXaWR0aCA9IHNjYWxlSGVpZ2h0O1xuXHRcdHNjYWxlUi5zdHJva2UoKTtcblxuXHRcdHNjYWxlWC5maWxsU3R5bGUgPSBzY2FsZVIuZmlsbFN0eWxlID0gJyNmZmYnO1xuXHRcdHNjYWxlWC5mb250ID0gYCR7IGNhbnZhc1guaGVpZ2h0ID4+IDEgfXB4IHNhbnMtc2VyaWZgO1xuXHRcdHNjYWxlUi5mb250ID0gYCR7IHNjYWxlSGVpZ2h0ID4+IDEgfXB4IHNhbnMtc2VyaWZgO1xuXHRcdHNjYWxlWC50ZXh0QWxpZ24gPSBzY2FsZVIudGV4dEFsaWduID0gJ2NlbnRlcic7XG5cblx0XHRmb3IgKCBjb25zdCBmcmVxIG9mIGZyZXFMYWJlbHMgKSB7XG5cdFx0XHRjb25zdCBsYWJlbCA9ICggZnJlcSA+PSAxMDAwICkgPyBgJHsgZnJlcSAvIDEwMDAgfWtgIDogZnJlcSxcblx0XHRcdFx0ICB4ICAgICA9IHRoaXMuX2xvZ1dpZHRoICogKCBNYXRoLmxvZzEwKCBmcmVxICkgLSB0aGlzLl9taW5Mb2cgKTtcblxuXHRcdFx0aWYgKCB4ID49IDAgJiYgeCA8PSB0aGlzLl9hbmFseXplcldpZHRoICkge1xuXHRcdFx0XHRzY2FsZVguZmlsbFRleHQoIGxhYmVsLCB0aGlzLl9pbml0aWFsWCArIHgsIGNhbnZhc1guaGVpZ2h0ICogLjc1ICk7XG5cdFx0XHRcdGlmICggeCA8IHRoaXMuX2FuYWx5emVyV2lkdGggKSAvLyBhdm9pZCB3cmFwcGluZy1hcm91bmQgdGhlIGxhc3QgbGFiZWwgYW5kIG92ZXJsYXBwaW5nIHRoZSBmaXJzdCBvbmVcblx0XHRcdFx0XHRyYWRpYWxMYWJlbCggeCwgbGFiZWwgKTtcblxuXHRcdFx0XHRpZiAoIHRoaXMuX21pcnJvciApIHtcblx0XHRcdFx0XHRzY2FsZVguZmlsbFRleHQoIGxhYmVsLCAoIHRoaXMuX2luaXRpYWxYIHx8IGNhbnZhcy53aWR0aCApIC0geCwgY2FudmFzWC5oZWlnaHQgKiAuNzUgKTtcblx0XHRcdFx0XHRpZiAoIHggPiAxMCApIC8vIGF2b2lkIG92ZXJsYXBwaW5nIG9mIGZpcnN0IGxhYmVscyBvbiBtaXJyb3IgbW9kZVxuXHRcdFx0XHRcdFx0cmFkaWFsTGFiZWwoIC14LCBsYWJlbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVkcmF3IHRoZSBjYW52YXNcblx0ICogdGhpcyBpcyBjYWxsZWQgNjAgdGltZXMgcGVyIHNlY29uZCBieSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKVxuXHQgKi9cblx0X2RyYXcoIHRpbWVzdGFtcCApIHtcblx0XHRjb25zdCBjdHggICAgICAgICAgICA9IHRoaXMuX2NhbnZhc0N0eCxcblx0XHRcdCAgY2FudmFzICAgICAgICAgPSBjdHguY2FudmFzLFxuXHRcdFx0ICBjYW52YXNYICAgICAgICA9IHRoaXMuX3NjYWxlWC5jYW52YXMsXG5cdFx0XHQgIGNhbnZhc1IgICAgICAgID0gdGhpcy5fc2NhbGVSLmNhbnZhcyxcblx0XHRcdCAgZW5lcmd5ICAgICAgICAgPSB0aGlzLl9lbmVyZ3ksXG5cdFx0XHQgIG1vZGUgICAgICAgICAgID0gdGhpcy5fbW9kZSxcblx0XHRcdCAgaXNBbHBoYUJhcnMgICAgPSB0aGlzLl9pc0FscGhhQmFycyxcblx0XHRcdCAgaXNMZWREaXNwbGF5ICAgPSB0aGlzLl9pc0xlZERpc3BsYXksXG5cdFx0XHQgIGlzTHVtaUJhcnMgICAgID0gdGhpcy5faXNMdW1pQmFycyxcblx0XHRcdCAgaXNPY3RhdmVCYW5kcyAgPSB0aGlzLl9pc09jdGF2ZUJhbmRzLFxuXHRcdFx0ICBpc091dGxpbmUgICAgICA9IHRoaXMuX2lzT3V0bGluZSxcblx0XHRcdCAgaXNSYWRpYWwgICAgICAgPSB0aGlzLl9yYWRpYWwsXG5cdFx0XHQgIGlzU3RlcmVvICAgICAgID0gdGhpcy5fc3RlcmVvLFxuXHRcdFx0ICBsaW5lV2lkdGggICAgICA9ICt0aGlzLmxpbmVXaWR0aCwgLy8gbWFrZSBzdXJlIHRoZSBkYW1uIHRoaW5nIGlzIGEgbnVtYmVyIVxuXHRcdFx0ICBtaXJyb3JNb2RlICAgICA9IHRoaXMuX21pcnJvcixcblx0XHRcdCAgY2hhbm5lbEhlaWdodCAgPSB0aGlzLl9jaGFubmVsSGVpZ2h0LFxuXHRcdFx0ICBjaGFubmVsR2FwICAgICA9IHRoaXMuX2NoYW5uZWxHYXAsXG5cdFx0XHQgIGFuYWx5emVySGVpZ2h0ID0gdGhpcy5fYW5hbHl6ZXJIZWlnaHQsXG5cdFx0XHQgIGFuYWx5emVyV2lkdGggID0gaXNSYWRpYWwgPyBjYW52YXMud2lkdGggOiB0aGlzLl9hbmFseXplcldpZHRoLFxuXHRcdFx0ICBpbml0aWFsWCAgICAgICA9IHRoaXMuX2luaXRpYWxYLFxuXHRcdFx0ICBmaW5hbFggICAgICAgICA9IGluaXRpYWxYICsgYW5hbHl6ZXJXaWR0aCxcblx0XHRcdCAgY2VudGVyWCAgICAgICAgPSBjYW52YXMud2lkdGggPj4gMSxcblx0XHRcdCAgY2VudGVyWSAgICAgICAgPSBjYW52YXMuaGVpZ2h0ID4+IDEsXG5cdFx0XHQgIHJhZGl1cyAgICAgICAgID0gdGhpcy5fcmFkaXVzLFxuXHRcdFx0ICBtYXhCYXJIZWlnaHQgICA9IGlzUmFkaWFsID8gTWF0aC5taW4oIGNlbnRlclgsIGNlbnRlclkgKSAtIHJhZGl1cyA6IGFuYWx5emVySGVpZ2h0LFxuXHRcdFx0ICB1c2VDYW52YXMgICAgICA9IHRoaXMudXNlQ2FudmFzO1xuXG5cdFx0aWYgKCBlbmVyZ3kudmFsID4gMCApXG5cdFx0XHR0aGlzLl9zcGluQW5nbGUgKz0gdGhpcy5fc3BpblNwZWVkICogUlBNO1xuXG5cdFx0Y29uc3Qgc3Ryb2tlSWYgPSBmbGFnID0+IHtcblx0XHRcdGlmICggZmxhZyAmJiBsaW5lV2lkdGggKSB7XG5cdFx0XHRcdGNvbnN0IGFscGhhID0gY3R4Lmdsb2JhbEFscGhhO1xuXHRcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSAxO1xuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IGFscGhhO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGhlbHBlciBmdW5jdGlvbiAtIGNvbnZlcnQgcGxhbmFyIFgsWSBjb29yZGluYXRlcyB0byByYWRpYWwgY29vcmRpbmF0ZXNcblx0XHRjb25zdCByYWRpYWxYWSA9ICggeCwgeSwgZGlyICkgPT4ge1xuXHRcdFx0Y29uc3QgaGVpZ2h0ID0gcmFkaXVzICsgeSxcblx0XHRcdFx0ICBhbmdsZSAgPSBkaXIgKiBUQVUgKiAoIHggLyBjYW52YXMud2lkdGggKSArIHRoaXMuX3NwaW5BbmdsZTtcblxuXHRcdFx0cmV0dXJuIFsgY2VudGVyWCArIGhlaWdodCAqIE1hdGguY29zKCBhbmdsZSApLCBjZW50ZXJZICsgaGVpZ2h0ICogTWF0aC5zaW4oIGFuZ2xlICkgXTtcblx0XHR9XG5cblx0XHQvLyBoZWxwZXIgZnVuY3Rpb24gLSBkcmF3IGEgcG9seWdvbiBvZiB3aWR0aCBgd2AgYW5kIGhlaWdodCBgaGAgYXQgKHgseSkgaW4gcmFkaWFsIG1vZGVcblx0XHRjb25zdCByYWRpYWxQb2x5ID0gKCB4LCB5LCB3LCBoLCBzdHJva2UgKSA9PiB7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRmb3IgKCBjb25zdCBkaXIgb2YgKCBtaXJyb3JNb2RlID8gWzEsLTFdIDogWzFdICkgKSB7XG5cdFx0XHRcdGN0eC5tb3ZlVG8oIC4uLnJhZGlhbFhZKCB4LCB5LCBkaXIgKSApO1xuXHRcdFx0XHRjdHgubGluZVRvKCAuLi5yYWRpYWxYWSggeCwgeSArIGgsIGRpciApICk7XG5cdFx0XHRcdGN0eC5saW5lVG8oIC4uLnJhZGlhbFhZKCB4ICsgdywgeSArIGgsIGRpciApICk7XG5cdFx0XHRcdGN0eC5saW5lVG8oIC4uLnJhZGlhbFhZKCB4ICsgdywgeSwgZGlyICkgKTtcblx0XHRcdH1cblxuXHRcdFx0c3Ryb2tlSWYoIHN0cm9rZSApO1xuXHRcdFx0Y3R4LmZpbGwoKTtcblx0XHR9XG5cblx0XHQvLyBMRUQgYXR0cmlidXRlcyBhbmQgaGVscGVyIGZ1bmN0aW9uIGZvciBiYXIgaGVpZ2h0IGNhbGN1bGF0aW9uXG5cdFx0Y29uc3QgWyBsZWRDb3VudCwgbGVkU3BhY2VILCBsZWRTcGFjZVYsIGxlZEhlaWdodCBdID0gdGhpcy5fbGVkcyB8fCBbXTtcblx0XHRjb25zdCBsZWRQb3NZID0gaGVpZ2h0ID0+ICggaGVpZ2h0ICogbGVkQ291bnQgfCAwICkgKiAoIGxlZEhlaWdodCArIGxlZFNwYWNlViApIC0gbGVkU3BhY2VWO1xuXG5cdFx0Ly8gc2VsZWN0IGJhY2tncm91bmQgY29sb3Jcblx0XHRjb25zdCBiZ0NvbG9yID0gKCAhIHRoaXMuc2hvd0JnQ29sb3IgfHwgaXNMZWREaXNwbGF5ICYmICEgdGhpcy5vdmVybGF5ICkgPyAnIzAwMCcgOiB0aGlzLl9ncmFkaWVudHNbIHRoaXMuX2dyYWRpZW50IF0uYmdDb2xvcjtcblxuXHRcdC8vIGNvbXB1dGUgdGhlIGVmZmVjdGl2ZSBiYXIgd2lkdGgsIGNvbnNpZGVyaW5nIHRoZSBzZWxlY3RlZCBiYXIgc3BhY2luZ1xuXHRcdC8vIGlmIGxlZCBlZmZlY3QgaXMgYWN0aXZlLCBlbnN1cmUgYXQgbGVhc3QgdGhlIHNwYWNpbmcgZnJvbSBsZWQgZGVmaW5pdGlvbnNcblx0XHRsZXQgd2lkdGggPSB0aGlzLl9iYXJXaWR0aCAtICggISBpc09jdGF2ZUJhbmRzID8gMCA6IE1hdGgubWF4KCBpc0xlZERpc3BsYXkgPyBsZWRTcGFjZUggOiAwLCB0aGlzLl9iYXJTcGFjZVB4ICkgKTtcblxuXHRcdC8vIG1ha2Ugc3VyZSB3aWR0aCBpcyBpbnRlZ2VyIGZvciBwaXhlbCBhY2N1cmF0ZSBjYWxjdWxhdGlvbiwgd2hlbiBubyBiYXIgc3BhY2luZyBpcyByZXF1aXJlZFxuXHRcdGlmICggdGhpcy5fYmFyU3BhY2UgPT0gMCAmJiAhIGlzTGVkRGlzcGxheSApXG5cdFx0XHR3aWR0aCB8PSAwO1xuXG5cdFx0bGV0IGN1cnJlbnRFbmVyZ3kgPSAwO1xuXG5cdFx0Y29uc3QgbkJhcnMgPSB0aGlzLl9iYXJzLmxlbmd0aDtcblxuXHRcdGZvciAoIGxldCBjaGFubmVsID0gMDsgY2hhbm5lbCA8IGlzU3RlcmVvICsgMTsgY2hhbm5lbCsrICkge1xuXG5cdFx0XHRjb25zdCBjaGFubmVsVG9wICAgICA9IGNoYW5uZWxIZWlnaHQgKiBjaGFubmVsICsgY2hhbm5lbEdhcCAqIGNoYW5uZWwsXG5cdFx0XHRcdCAgY2hhbm5lbEJvdHRvbSAgPSBjaGFubmVsVG9wICsgY2hhbm5lbEhlaWdodCxcblx0XHRcdFx0ICBhbmFseXplckJvdHRvbSA9IGNoYW5uZWxUb3AgKyBhbmFseXplckhlaWdodCAtICggaXNMZWREaXNwbGF5ICYmICEgdGhpcy5fbWF4aW1pemVMZWRzID8gbGVkU3BhY2VWIDogMCApO1xuXG5cdFx0XHRpZiAoIHVzZUNhbnZhcyApIHtcblx0XHRcdFx0Ly8gY2xlYXIgdGhlIGNoYW5uZWwgYXJlYSwgaWYgaW4gb3ZlcmxheSBtb2RlXG5cdFx0XHRcdC8vIHRoaXMgaXMgZG9uZSBwZXIgY2hhbm5lbCB0byBjbGVhciBhbnkgcmVzaWR1ZSBiZWxvdyAwIG9mZiB0aGUgdG9wIGNoYW5uZWwgKGVzcGVjaWFsbHkgaW4gbGluZSBncmFwaCBtb2RlIHdpdGggbGluZVdpZHRoID4gMSlcblx0XHRcdFx0aWYgKCB0aGlzLm92ZXJsYXkgKVxuXHRcdFx0XHRcdGN0eC5jbGVhclJlY3QoIDAsIGNoYW5uZWxUb3AgLSBjaGFubmVsR2FwLCBjYW52YXMud2lkdGgsIGNoYW5uZWxIZWlnaHQgKyBjaGFubmVsR2FwICk7XG5cblx0XHRcdFx0Ly8gZmlsbCB0aGUgYW5hbHl6ZXIgYmFja2dyb3VuZCBpZiBuZWVkZWQgKG5vdCBvdmVybGF5IG9yIG92ZXJsYXkgKyBzaG93QmdDb2xvcilcblx0XHRcdFx0aWYgKCAhIHRoaXMub3ZlcmxheSB8fCB0aGlzLnNob3dCZ0NvbG9yICkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vdmVybGF5IClcblx0XHRcdFx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuYmdBbHBoYTtcblxuXHRcdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBiZ0NvbG9yO1xuXG5cdFx0XHRcdFx0Ly8gZXhjbHVkZSB0aGUgcmVmbGVjdGlvbiBhcmVhIHdoZW4gb3ZlcmxheSBpcyB0cnVlIGFuZCByZWZsZXhBbHBoYSA9PSAxIChhdm9pZHMgYWxwaGEgb3ZlciBhbHBoYSBkaWZmZXJlbmNlLCBpbiBjYXNlIGJnQWxwaGEgPCAxKVxuXHRcdFx0XHRcdGlmICggISBpc1JhZGlhbCB8fCBjaGFubmVsID09IDAgKVxuXHRcdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KCBpbml0aWFsWCwgY2hhbm5lbFRvcCAtIGNoYW5uZWxHYXAsIGFuYWx5emVyV2lkdGgsICggdGhpcy5vdmVybGF5ICYmIHRoaXMucmVmbGV4QWxwaGEgPT0gMSA/IGFuYWx5emVySGVpZ2h0IDogY2hhbm5lbEhlaWdodCApICsgY2hhbm5lbEdhcCApO1xuXG5cdFx0XHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gMTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGRyYXcgZEIgc2NhbGUgKFktYXhpcylcblx0XHRcdFx0aWYgKCB0aGlzLnNob3dTY2FsZVkgJiYgISBpc0x1bWlCYXJzICYmICEgaXNSYWRpYWwgKSB7XG5cdFx0XHRcdFx0Y29uc3Qgc2NhbGVXaWR0aCA9IGNhbnZhc1guaGVpZ2h0LFxuXHRcdFx0XHRcdFx0ICBmb250U2l6ZSAgID0gc2NhbGVXaWR0aCA+PiAxLFxuXHRcdFx0XHRcdFx0ICBtaW5kQiAgICAgID0gdGhpcy5fYW5hbHl6ZXJbMF0ubWluRGVjaWJlbHMsXG5cdFx0XHRcdFx0XHQgIG1heGRCICAgICAgPSB0aGlzLl9hbmFseXplclswXS5tYXhEZWNpYmVscyxcblx0XHRcdFx0XHRcdCAgaW50ZXJ2YWwgICA9IGFuYWx5emVySGVpZ2h0IC8gKCBtYXhkQiAtIG1pbmRCICk7XG5cblx0XHRcdFx0XHRjdHguZmlsbFN0eWxlID0gJyM4ODgnO1xuXHRcdFx0XHRcdGN0eC5mb250ID0gYCR7Zm9udFNpemV9cHggc2Fucy1zZXJpZmA7XG5cdFx0XHRcdFx0Y3R4LnRleHRBbGlnbiA9ICdyaWdodCc7XG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IDE7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgZGIgPSBtYXhkQjsgZGIgPiBtaW5kQjsgZGIgLT0gNSApIHtcblx0XHRcdFx0XHRcdGNvbnN0IHBvc1kgPSBjaGFubmVsVG9wICsgKCBtYXhkQiAtIGRiICkgKiBpbnRlcnZhbCxcblx0XHRcdFx0XHRcdFx0ICBldmVuID0gKCBkYiAlIDIgPT0gMCApIHwgMDtcblxuXHRcdFx0XHRcdFx0aWYgKCBldmVuICkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBsYWJlbFkgPSBwb3NZICsgZm9udFNpemUgKiAoIHBvc1kgPT0gY2hhbm5lbFRvcCA/IC44IDogLjM1ICk7XG5cdFx0XHRcdFx0XHRcdGlmICggbWlycm9yTW9kZSAhPSAtMSApXG5cdFx0XHRcdFx0XHRcdFx0Y3R4LmZpbGxUZXh0KCBkYiwgc2NhbGVXaWR0aCAqIC44NSwgbGFiZWxZICk7XG5cdFx0XHRcdFx0XHRcdGlmICggbWlycm9yTW9kZSAhPSAxIClcblx0XHRcdFx0XHRcdFx0XHRjdHguZmlsbFRleHQoIGRiLCBjYW52YXMud2lkdGggLSBzY2FsZVdpZHRoICogLjEsIGxhYmVsWSApO1xuXHRcdFx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSAnIzg4OCc7XG5cdFx0XHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaChbMiw0XSk7XG5cdFx0XHRcdFx0XHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IDA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gJyM1NTUnO1xuXHRcdFx0XHRcdFx0XHRjdHguc2V0TGluZURhc2goWzIsOF0pO1xuXHRcdFx0XHRcdFx0XHRjdHgubGluZURhc2hPZmZzZXQgPSAxO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdFx0XHRjdHgubW92ZVRvKCBpbml0aWFsWCArIHNjYWxlV2lkdGggKiBldmVuICogKCBtaXJyb3JNb2RlICE9IC0xICksIH5+cG9zWSArIC41ICk7IC8vIGZvciBzaGFycCAxcHggbGluZSAoaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEzODc5NDAyLzIzNzAzODUpXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKCBmaW5hbFggLSBzY2FsZVdpZHRoICogZXZlbiAqICggbWlycm9yTW9kZSAhPSAxICksIH5+cG9zWSArIC41ICk7XG5cdFx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIHJlc3RvcmUgbGluZSBwcm9wZXJ0aWVzXG5cdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblx0XHRcdFx0XHRjdHgubGluZURhc2hPZmZzZXQgPSAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gc2V0IGxpbmUgd2lkdGggYW5kIGRhc2ggZm9yIExFRHMgZWZmZWN0XG5cdFx0XHRcdGlmICggaXNMZWREaXNwbGF5ICkge1xuXHRcdFx0XHRcdGN0eC5zZXRMaW5lRGFzaCggWyBsZWRIZWlnaHQsIGxlZFNwYWNlViBdICk7XG5cdFx0XHRcdFx0Y3R4LmxpbmVXaWR0aCA9IHdpZHRoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2UgLy8gZm9yIG91dGxpbmUgZWZmZWN0IGVuc3VyZSBsaW5ld2lkdGggaXMgbm90IGdyZWF0ZXIgdGhhbiBoYWxmIHRoZSBiYXIgd2lkdGhcblx0XHRcdFx0XHRjdHgubGluZVdpZHRoID0gaXNPdXRsaW5lID8gTWF0aC5taW4oIGxpbmVXaWR0aCwgd2lkdGggLyAyICkgOiBsaW5lV2lkdGg7XG5cblx0XHRcdFx0Ly8gc2V0IHNlbGVjdGVkIGdyYWRpZW50IGZvciBmaWxsIGFuZCBzdHJva2Vcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuX2NhbnZhc0dyYWRpZW50O1xuXHRcdFx0fSAvLyBpZiAoIHVzZUNhbnZhcyApXG5cblx0XHRcdC8vIGdldCBhIG5ldyBhcnJheSBvZiBkYXRhIGZyb20gdGhlIEZGVFxuXHRcdFx0Y29uc3QgZmZ0RGF0YSA9IHRoaXMuX2ZmdERhdGFbIGNoYW5uZWwgXTtcblx0XHRcdHRoaXMuX2FuYWx5emVyWyBjaGFubmVsIF0uZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoIGZmdERhdGEgKTtcblxuXHRcdFx0Ly8gaGVscGVyIGZ1bmN0aW9uIGZvciBGRlQgZGF0YSBpbnRlcnBvbGF0aW9uXG5cdFx0XHRjb25zdCBpbnRlcnBvbGF0ZSA9ICggYmluLCByYXRpbyApID0+IGZmdERhdGFbIGJpbiBdICsgKCBmZnREYXRhWyBiaW4gKyAxIF0gLSBmZnREYXRhWyBiaW4gXSApICogcmF0aW87XG5cblx0XHRcdC8vIHN0YXJ0IGRyYXdpbmcgcGF0aCAoZm9yIG1vZGUgMTApXG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRcdC8vIHN0b3JlIGxpbmUgZ3JhcGggcG9pbnRzIHRvIGNyZWF0ZSBtaXJyb3IgZWZmZWN0IGluIHJhZGlhbCBtb2RlXG5cdFx0XHRsZXQgcG9pbnRzID0gW107XG5cblx0XHRcdC8vIGRyYXcgYmFycyAvIGxpbmVzXG5cblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IG5CYXJzOyBpKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgYmFyID0gdGhpcy5fYmFyc1sgaSBdLFxuXHRcdFx0XHRcdCAgeyBiaW5MbywgYmluSGksIHJhdGlvTG8sIHJhdGlvSGkgfSA9IGJhcjtcblxuXHRcdFx0XHRsZXQgYmFySGVpZ2h0ID0gTWF0aC5tYXgoIGludGVycG9sYXRlKCBiaW5MbywgcmF0aW9MbyApLCBpbnRlcnBvbGF0ZSggYmluSGksIHJhdGlvSGkgKSApO1xuXG5cdFx0XHRcdC8vIGNoZWNrIGFkZGl0aW9uYWwgYmlucyAoaWYgYW55KSBmb3IgdGhpcyBiYXIgYW5kIGtlZXAgdGhlIGhpZ2hlc3QgdmFsdWVcblx0XHRcdFx0Zm9yICggbGV0IGogPSBiaW5MbyArIDE7IGogPCBiaW5IaTsgaisrICkge1xuXHRcdFx0XHRcdGlmICggZmZ0RGF0YVsgaiBdID4gYmFySGVpZ2h0IClcblx0XHRcdFx0XHRcdGJhckhlaWdodCA9IGZmdERhdGFbIGogXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhckhlaWdodCAvPSAyNTU7XG5cdFx0XHRcdGJhci52YWx1ZVsgY2hhbm5lbCBdID0gYmFySGVpZ2h0O1xuXHRcdFx0XHRjdXJyZW50RW5lcmd5ICs9IGJhckhlaWdodDtcblxuXHRcdFx0XHQvLyB1cGRhdGUgYmFyIHBlYWtcblx0XHRcdFx0aWYgKCBiYXIucGVha1sgY2hhbm5lbCBdID4gMCApIHtcblx0XHRcdFx0XHRiYXIuaG9sZFsgY2hhbm5lbCBdLS07XG5cdFx0XHRcdFx0Ly8gaWYgaG9sZCBpcyBuZWdhdGl2ZSwgaXQgYmVjb21lcyB0aGUgXCJhY2NlbGVyYXRpb25cIiBmb3IgcGVhayBkcm9wXG5cdFx0XHRcdFx0aWYgKCBiYXIuaG9sZFsgY2hhbm5lbCBdIDwgMCApXG5cdFx0XHRcdFx0XHRiYXIucGVha1sgY2hhbm5lbCBdICs9IGJhci5ob2xkWyBjaGFubmVsIF0gLyBtYXhCYXJIZWlnaHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjaGVjayBpZiBpdCdzIGEgbmV3IHBlYWsgZm9yIHRoaXMgYmFyXG5cdFx0XHRcdGlmICggYmFySGVpZ2h0ID49IGJhci5wZWFrWyBjaGFubmVsIF0gKSB7XG5cdFx0XHRcdFx0YmFyLnBlYWtbIGNoYW5uZWwgXSA9IGJhckhlaWdodDtcblx0XHRcdFx0XHRiYXIuaG9sZFsgY2hhbm5lbCBdID0gMzA7IC8vIHNldCBwZWFrIGhvbGQgdGltZSB0byAzMCBmcmFtZXMgKDAuNXMpXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBub3QgdXNpbmcgdGhlIGNhbnZhcywgbW92ZSBlYXJsaWVyIHRvIHRoZSBuZXh0IGJhclxuXHRcdFx0XHRpZiAoICEgdXNlQ2FudmFzIClcblx0XHRcdFx0XHRjb250aW51ZTtcblxuXHRcdFx0XHQvLyBzZXQgb3BhY2l0eSBmb3IgYmFyIGVmZmVjdHNcblx0XHRcdFx0aWYgKCBpc0x1bWlCYXJzIHx8IGlzQWxwaGFCYXJzIClcblx0XHRcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBiYXJIZWlnaHQ7XG5cdFx0XHRcdGVsc2UgaWYgKCBpc091dGxpbmUgKVxuXHRcdFx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuZmlsbEFscGhhO1xuXG5cdFx0XHRcdC8vIG5vcm1hbGl6ZSBiYXJIZWlnaHRcblx0XHRcdFx0aWYgKCBpc0xlZERpc3BsYXkgKSB7XG5cdFx0XHRcdFx0YmFySGVpZ2h0ID0gbGVkUG9zWSggYmFySGVpZ2h0ICk7XG5cdFx0XHRcdFx0aWYgKCBiYXJIZWlnaHQgPCAwIClcblx0XHRcdFx0XHRcdGJhckhlaWdodCA9IDA7IC8vIHByZXZlbnQgc2hvd2luZyBsZWRzIGJlbG93IDAgd2hlbiBvdmVybGF5IGFuZCByZWZsZXggYXJlIGFjdGl2ZVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRiYXJIZWlnaHQgPSBiYXJIZWlnaHQgKiBtYXhCYXJIZWlnaHQgfCAwO1xuXG5cdFx0XHRcdC8vIGludmVydCBiYXIgZm9yIHJhZGlhbCBjaGFubmVsIDFcblx0XHRcdFx0aWYgKCBpc1JhZGlhbCAmJiBjaGFubmVsID09IDEgKVxuXHRcdFx0XHRcdGJhckhlaWdodCAqPSAtMTtcblxuXHRcdFx0XHQvLyBiYXIgd2lkdGggbWF5IG5lZWQgc21hbGwgYWRqdXN0bWVudHMgZm9yIHNvbWUgYmFycywgd2hlbiBiYXJTcGFjZSA9PSAwXG5cdFx0XHRcdGxldCBhZGpXaWR0aCA9IHdpZHRoLFxuXHRcdFx0XHRcdHBvc1ggICAgID0gYmFyLnBvc1g7XG5cblx0XHRcdFx0Ly8gRHJhdyBjdXJyZW50IGJhciBvciBsaW5lIHNlZ21lbnRcblxuXHRcdFx0XHRpZiAoIG1vZGUgPT0gMTAgKSB7XG5cdFx0XHRcdFx0Ly8gY29tcHV0ZSB0aGUgYXZlcmFnZSBiZXR3ZWVuIHRoZSBpbml0aWFsIGJhciAoaT09MCkgYW5kIHRoZSBuZXh0IG9uZVxuXHRcdFx0XHRcdC8vIHVzZWQgdG8gc21vb3RoIHRoZSBjdXJ2ZSB3aGVuIHRoZSBpbml0aWFsIHBvc1ggaXMgb2ZmIHRoZSBzY3JlZW4sIGluIG1pcnJvciBhbmQgcmFkaWFsIG1vZGVzXG5cdFx0XHRcdFx0Y29uc3QgbmV4dEJhckF2ZyA9IGkgPyAwIDogKCBmZnREYXRhWyB0aGlzLl9iYXJzWzFdLmJpbkxvIF0gLyAyNTUgKiBtYXhCYXJIZWlnaHQgKiAoICEgaXNSYWRpYWwgfHwgISBjaGFubmVsIHx8IC0gMSApICsgYmFySGVpZ2h0ICkgLyAyO1xuXG5cdFx0XHRcdFx0aWYgKCBpc1JhZGlhbCApIHtcblx0XHRcdFx0XHRcdGlmICggaSA9PSAwIClcblx0XHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyggLi4ucmFkaWFsWFkoIDAsICggcG9zWCA8IDAgPyBuZXh0QmFyQXZnIDogYmFySGVpZ2h0ICksIDEgKSApO1xuXHRcdFx0XHRcdFx0Ly8gZHJhdyBsaW5lIHRvIHRoZSBjdXJyZW50IHBvaW50LCBhdm9pZGluZyBvdmVybGFwcGluZyB3cmFwLWFyb3VuZCBmcmVxdWVuY2llc1xuXHRcdFx0XHRcdFx0aWYgKCBwb3NYID49IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHBvaW50ID0gWyBwb3NYLCBiYXJIZWlnaHQgXTtcblx0XHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyggLi4ucmFkaWFsWFkoIC4uLnBvaW50LCAxICkgKTtcblx0XHRcdFx0XHRcdFx0cG9pbnRzLnB1c2goIHBvaW50ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgeyAvLyBMaW5lYXJcblx0XHRcdFx0XHRcdGlmICggaSA9PSAwICkge1xuXHRcdFx0XHRcdFx0XHQvLyBzdGFydCB0aGUgbGluZSBvZmYtc2NyZWVuIHVzaW5nIHRoZSBwcmV2aW91cyBGRlQgYmluIHZhbHVlIGFzIHRoZSBpbml0aWFsIGFtcGxpdHVkZVxuXHRcdFx0XHRcdFx0XHRpZiAoIG1pcnJvck1vZGUgIT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgcHJldkZGVERhdGEgPSBiaW5MbyA/IGZmdERhdGFbIGJpbkxvIC0gMSBdIC8gMjU1ICogbWF4QmFySGVpZ2h0IDogYmFySGVpZ2h0OyAvLyB1c2UgcHJldmlvdXMgRkZUIGJpbiB2YWx1ZSwgd2hlbiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0XHRjdHgubW92ZVRvKCBpbml0aWFsWCAtIGxpbmVXaWR0aCwgYW5hbHl6ZXJCb3R0b20gLSBwcmV2RkZURGF0YSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRjdHgubW92ZVRvKCBpbml0aWFsWCwgYW5hbHl6ZXJCb3R0b20gLSAoIHBvc1ggPCBpbml0aWFsWCA/IG5leHRCYXJBdmcgOiBiYXJIZWlnaHQgKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gZHJhdyBsaW5lIHRvIHRoZSBjdXJyZW50IHBvaW50XG5cdFx0XHRcdFx0XHQvLyBhdm9pZCBYIHZhbHVlcyBsb3dlciB0aGFuIHRoZSBvcmlnaW4gd2hlbiBtaXJyb3JpbmcgbGVmdCwgb3RoZXJ3aXNlIGRyYXcgdGhlbSBmb3IgYmVzdCBncmFwaCBhY2N1cmFjeVxuXHRcdFx0XHRcdFx0aWYgKCBtaXJyb3JNb2RlICE9IC0xIHx8IHBvc1ggPj0gaW5pdGlhbFggKVxuXHRcdFx0XHRcdFx0XHRjdHgubGluZVRvKCBwb3NYLCBhbmFseXplckJvdHRvbSAtIGJhckhlaWdodCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpZiAoIG1vZGUgPiAwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBpc0xlZERpc3BsYXkgKVxuXHRcdFx0XHRcdFx0XHRwb3NYICs9IE1hdGgubWF4KCBsZWRTcGFjZUggLyAyLCB0aGlzLl9iYXJTcGFjZVB4IC8gMiApO1xuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGlmICggdGhpcy5fYmFyU3BhY2UgPT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRwb3NYIHw9IDA7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBpID4gMCAmJiBwb3NYID4gdGhpcy5fYmFyc1sgaSAtIDEgXS5wb3NYICsgd2lkdGggKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwb3NYLS07XG5cdFx0XHRcdFx0XHRcdFx0XHRhZGpXaWR0aCsrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0cG9zWCArPSB0aGlzLl9iYXJTcGFjZVB4IC8gMjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIGlzTGVkRGlzcGxheSApIHtcblx0XHRcdFx0XHRcdGNvbnN0IHggPSBwb3NYICsgd2lkdGggLyAyO1xuXHRcdFx0XHRcdFx0Ly8gZHJhdyBcInVubGl0XCIgbGVkc1xuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLnNob3dCZ0NvbG9yICYmICEgdGhpcy5vdmVybGF5ICkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBhbHBoYSA9IGN0eC5nbG9iYWxBbHBoYTtcblx0XHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdFx0XHRjdHgubW92ZVRvKCB4LCBjaGFubmVsVG9wICk7XG5cdFx0XHRcdFx0XHRcdGN0eC5saW5lVG8oIHgsIGFuYWx5emVyQm90dG9tICk7XG5cdFx0XHRcdFx0XHRcdGN0eC5zdHJva2VTdHlsZSA9ICcjN2Y3ZjdmMjInO1xuXHRcdFx0XHRcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSAxO1xuXHRcdFx0XHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdFx0XHRcdC8vIHJlc3RvcmUgcHJvcGVydGllc1xuXHRcdFx0XHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuXHRcdFx0XHRcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBhbHBoYTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdGN0eC5tb3ZlVG8oIHgsIGlzTHVtaUJhcnMgPyBjaGFubmVsVG9wIDogYW5hbHl6ZXJCb3R0b20gKTtcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oIHgsIGlzTHVtaUJhcnMgPyBjaGFubmVsQm90dG9tIDogYW5hbHl6ZXJCb3R0b20gLSBiYXJIZWlnaHQgKTtcblx0XHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIHBvc1ggPj0gaW5pdGlhbFggKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGlzUmFkaWFsIClcblx0XHRcdFx0XHRcdFx0cmFkaWFsUG9seSggcG9zWCwgMCwgYWRqV2lkdGgsIGJhckhlaWdodCwgaXNPdXRsaW5lICk7XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgeCA9IHBvc1gsXG5cdFx0XHRcdFx0XHRcdFx0ICB5ID0gaXNMdW1pQmFycyA/IGNoYW5uZWxUb3AgOiBhbmFseXplckJvdHRvbSxcblx0XHRcdFx0XHRcdFx0XHQgIHcgPSBhZGpXaWR0aCxcblx0XHRcdFx0XHRcdFx0XHQgIGggPSBpc0x1bWlCYXJzID8gY2hhbm5lbEJvdHRvbSA6IC1iYXJIZWlnaHQ7XG5cblx0XHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdFx0XHRjdHgubW92ZVRvKCB4LCB5ICk7XG5cdFx0XHRcdFx0XHRcdGN0eC5saW5lVG8oIHgsIHkgKyBoICk7XG5cdFx0XHRcdFx0XHRcdGN0eC5saW5lVG8oIHggKyB3LCB5ICsgaCApO1xuXHRcdFx0XHRcdFx0XHRjdHgubGluZVRvKCB4ICsgdywgeSApO1xuXG5cdFx0XHRcdFx0XHRcdHN0cm9rZUlmKCBpc091dGxpbmUgKTtcblx0XHRcdFx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBEcmF3IHBlYWtcblx0XHRcdFx0Y29uc3QgcGVhayA9IGJhci5wZWFrWyBjaGFubmVsIF07XG5cdFx0XHRcdGlmICggcGVhayA+IDAgJiYgdGhpcy5zaG93UGVha3MgJiYgISBpc0x1bWlCYXJzICYmIHBvc1ggPj0gaW5pdGlhbFggJiYgcG9zWCA8IGZpbmFsWCApIHtcblx0XHRcdFx0XHQvLyBjaG9vc2UgdGhlIGJlc3Qgb3BhY2l0eSBmb3IgdGhlIHBlYWtzXG5cdFx0XHRcdFx0aWYgKCBpc091dGxpbmUgJiYgbGluZVdpZHRoID4gMCApXG5cdFx0XHRcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSAxO1xuXHRcdFx0XHRcdGVsc2UgaWYgKCBpc0FscGhhQmFycyApXG5cdFx0XHRcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBwZWFrO1xuXG5cdFx0XHRcdFx0Ly8gcmVuZGVyIHBlYWsgYWNjb3JkaW5nIHRvIGN1cnJlbnQgbW9kZSAvIGVmZmVjdFxuXHRcdFx0XHRcdGlmICggaXNMZWREaXNwbGF5IClcblx0XHRcdFx0XHRcdGN0eC5maWxsUmVjdCggcG9zWCxcdGFuYWx5emVyQm90dG9tIC0gbGVkUG9zWSggcGVhayApLCB3aWR0aCwgbGVkSGVpZ2h0ICk7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoICEgaXNSYWRpYWwgKVxuXHRcdFx0XHRcdFx0Y3R4LmZpbGxSZWN0KCBwb3NYLCBhbmFseXplckJvdHRvbSAtIHBlYWsgKiBtYXhCYXJIZWlnaHQsIGFkaldpZHRoLCAyICk7XG5cdFx0XHRcdFx0ZWxzZSBpZiAoIG1vZGUgIT0gMTAgKSAvLyByYWRpYWwgLSBubyBwZWFrcyBmb3IgbW9kZSAxMFxuXHRcdFx0XHRcdFx0cmFkaWFsUG9seSggcG9zWCwgcGVhayAqIG1heEJhckhlaWdodCAqICggISBjaGFubmVsIHx8IC0xICksIGFkaldpZHRoLCAtMiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gLy8gZm9yICggbGV0IGkgPSAwOyBpIDwgbkJhcnM7IGkrKyApXG5cblx0XHRcdC8vIGlmIG5vdCB1c2luZyB0aGUgY2FudmFzLCBtb3ZlIGVhcmxpZXIgdG8gdGhlIG5leHQgY2hhbm5lbFxuXHRcdFx0aWYgKCAhIHVzZUNhbnZhcyApXG5cdFx0XHRcdGNvbnRpbnVlO1xuXG5cdFx0XHQvLyByZXN0b3JlIGdsb2JhbCBhbHBoYVxuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gMTtcblxuXHRcdFx0Ly8gRmlsbC9zdHJva2UgZHJhd2luZyBwYXRoIGZvciBtb2RlIDEwXG5cdFx0XHRpZiAoIG1vZGUgPT0gMTAgKSB7XG5cdFx0XHRcdGlmICggaXNSYWRpYWwgKSB7XG5cdFx0XHRcdFx0aWYgKCBtaXJyb3JNb2RlICkge1xuXHRcdFx0XHRcdFx0bGV0IHA7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIHAgPSBwb2ludHMucG9wKCkgKVxuXHRcdFx0XHRcdFx0XHRjdHgubGluZVRvKCAuLi5yYWRpYWxYWSggLi4ucCwgLTEgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGxpbmVXaWR0aCA+IDAgKVxuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblxuXHRcdFx0XHRpZiAoIHRoaXMuZmlsbEFscGhhID4gMCApIHtcblx0XHRcdFx0XHRpZiAoIGlzUmFkaWFsICkge1xuXHRcdFx0XHRcdFx0Ly8gZXhjbHVkZSB0aGUgY2VudGVyIGNpcmNsZSBmcm9tIHRoZSBmaWxsIGFyZWFcblx0XHRcdFx0XHRcdGN0eC5tb3ZlVG8oIGNlbnRlclggKyByYWRpdXMsIGNlbnRlclkgKTtcblx0XHRcdFx0XHRcdGN0eC5hcmMoIGNlbnRlclgsIGNlbnRlclksIHJhZGl1cywgMCwgVEFVLCB0cnVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgeyAvLyBjbG9zZSB0aGUgZmlsbCBhcmVhXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKCBmaW5hbFgsIGFuYWx5emVyQm90dG9tICk7XG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKCBpbml0aWFsWCwgYW5hbHl6ZXJCb3R0b20gKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmZpbGxBbHBoYTtcblx0XHRcdFx0XHRjdHguZmlsbCgpO1xuXHRcdFx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVmbGV4IGVmZmVjdFxuXHRcdFx0aWYgKCB0aGlzLl9yZWZsZXhSYXRpbyA+IDAgJiYgISBpc0x1bWlCYXJzICkge1xuXHRcdFx0XHRsZXQgcG9zWSwgaGVpZ2h0O1xuXHRcdFx0XHRpZiAoIHRoaXMucmVmbGV4Rml0IHx8IGlzU3RlcmVvICkgeyAvLyBhbHdheXMgZml0IHJlZmxleCBpbiBzdGVyZW8gbW9kZVxuXHRcdFx0XHRcdHBvc1kgICA9IGlzU3RlcmVvICYmIGNoYW5uZWwgPT0gMCA/IGNoYW5uZWxIZWlnaHQgKyBjaGFubmVsR2FwIDogMDtcblx0XHRcdFx0XHRoZWlnaHQgPSBjaGFubmVsSGVpZ2h0IC0gYW5hbHl6ZXJIZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0cG9zWSAgID0gY2FudmFzLmhlaWdodCAtIGFuYWx5emVySGVpZ2h0ICogMjtcblx0XHRcdFx0XHRoZWlnaHQgPSBhbmFseXplckhlaWdodDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNldCBhbHBoYSBhbmQgYnJpZ2h0bmVzcyBmb3IgdGhlIHJlZmxlY3Rpb25cblx0XHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gdGhpcy5yZWZsZXhBbHBoYTtcblx0XHRcdFx0aWYgKCB0aGlzLnJlZmxleEJyaWdodCAhPSAxIClcblx0XHRcdFx0XHRjdHguZmlsdGVyID0gYGJyaWdodG5lc3MoJHt0aGlzLnJlZmxleEJyaWdodH0pYDtcblxuXHRcdFx0XHQvLyBjcmVhdGUgdGhlIHJlZmxlY3Rpb25cblx0XHRcdFx0Y3R4LnNldFRyYW5zZm9ybSggMSwgMCwgMCwgLTEsIDAsIGNhbnZhcy5oZWlnaHQgKTtcblx0XHRcdFx0Y3R4LmRyYXdJbWFnZSggY2FudmFzLCAwLCBjaGFubmVsVG9wLCBjYW52YXMud2lkdGgsIGFuYWx5emVySGVpZ2h0LCAwLCBwb3NZLCBjYW52YXMud2lkdGgsIGhlaWdodCApO1xuXG5cdFx0XHRcdC8vIHJlc2V0IGNoYW5nZWQgcHJvcGVydGllc1xuXHRcdFx0XHRjdHguc2V0VHJhbnNmb3JtKCAxLCAwLCAwLCAxLCAwLCAwICk7XG5cdFx0XHRcdGN0eC5maWx0ZXIgPSAnbm9uZSc7XG5cdFx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IDE7XG5cdFx0XHR9XG5cblx0XHR9IC8vIGZvciAoIGxldCBjaGFubmVsID0gMDsgY2hhbm5lbCA8IGlzU3RlcmVvICsgMTsgY2hhbm5lbCsrICkge1xuXG5cdFx0Ly8gVXBkYXRlIGVuZXJneVxuXHRcdGVuZXJneS52YWwgPSBjdXJyZW50RW5lcmd5IC8gKCBuQmFycyA8PCBpc1N0ZXJlbyApO1xuXHRcdGlmICggZW5lcmd5LnZhbCA+PSBlbmVyZ3kucGVhayApIHtcblx0XHRcdGVuZXJneS5wZWFrID0gZW5lcmd5LnZhbDtcblx0XHRcdGVuZXJneS5ob2xkID0gMzA7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aWYgKCBlbmVyZ3kuaG9sZCA+IDAgKVxuXHRcdFx0XHRlbmVyZ3kuaG9sZC0tO1xuXHRcdFx0ZWxzZSBpZiAoIGVuZXJneS5wZWFrID4gMCApXG5cdFx0XHRcdGVuZXJneS5wZWFrICo9ICggMzAgKyBlbmVyZ3kuaG9sZC0tICkgLyAzMDsgLy8gZGVjYXkgKGRyb3BzIHRvIHplcm8gaW4gMzAgZnJhbWVzKVxuXHRcdH1cblxuXHRcdGlmICggdXNlQ2FudmFzICkge1xuXHRcdFx0Ly8gTWlycm9yIGVmZmVjdFxuXHRcdFx0aWYgKCBtaXJyb3JNb2RlICYmICEgaXNSYWRpYWwgKSB7XG5cdFx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0oIC0xLCAwLCAwLCAxLCBjYW52YXMud2lkdGggLSBpbml0aWFsWCwgMCApO1xuXHRcdFx0XHRjdHguZHJhd0ltYWdlKCBjYW52YXMsIGluaXRpYWxYLCAwLCBjZW50ZXJYLCBjYW52YXMuaGVpZ2h0LCAwLCAwLCBjZW50ZXJYLCBjYW52YXMuaGVpZ2h0ICk7XG5cdFx0XHRcdGN0eC5zZXRUcmFuc2Zvcm0oIDEsIDAsIDAsIDEsIDAsIDAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcmVzdG9yZSBzb2xpZCBsaW5lc1xuXHRcdFx0Y3R4LnNldExpbmVEYXNoKFtdKTtcblxuXHRcdFx0Ly8gZHJhdyBmcmVxdWVuY3kgc2NhbGUgKFgtYXhpcylcblx0XHRcdGlmICggdGhpcy5zaG93U2NhbGVYICkge1xuXHRcdFx0XHRpZiAoIGlzUmFkaWFsICkge1xuXHRcdFx0XHRcdGN0eC5zYXZlKCk7XG5cdFx0XHRcdFx0Y3R4LnRyYW5zbGF0ZSggY2VudGVyWCwgY2VudGVyWSApO1xuXHRcdFx0XHRcdGlmICggdGhpcy5fc3BpblNwZWVkIClcblx0XHRcdFx0XHRcdGN0eC5yb3RhdGUoIHRoaXMuX3NwaW5BbmdsZSArIEhBTEZfUEkgKTtcblx0XHRcdFx0XHRjdHguZHJhd0ltYWdlKCBjYW52YXNSLCAtY2FudmFzUi53aWR0aCA+PiAxLCAtY2FudmFzUi53aWR0aCA+PiAxICk7XG5cdFx0XHRcdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0Y3R4LmRyYXdJbWFnZSggY2FudmFzWCwgMCwgY2FudmFzLmhlaWdodCAtIGNhbnZhc1guaGVpZ2h0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gY2FsY3VsYXRlIGFuZCB1cGRhdGUgY3VycmVudCBmcmFtZSByYXRlXG5cblx0XHR0aGlzLl9mcmFtZSsrO1xuXHRcdGNvbnN0IGVsYXBzZWQgPSB0aW1lc3RhbXAgLSB0aGlzLl90aW1lO1xuXG5cdFx0aWYgKCBlbGFwc2VkID49IDEwMDAgKSB7XG5cdFx0XHR0aGlzLl9mcHMgPSB0aGlzLl9mcmFtZSAvICggZWxhcHNlZCAvIDEwMDAgKTtcblx0XHRcdHRoaXMuX2ZyYW1lID0gMDtcblx0XHRcdHRoaXMuX3RpbWUgPSB0aW1lc3RhbXA7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5zaG93RlBTICkge1xuXHRcdFx0Y29uc3Qgc2l6ZSA9IGNhbnZhc1guaGVpZ2h0O1xuXHRcdFx0Y3R4LmZvbnQgPSBgYm9sZCAke3NpemV9cHggc2Fucy1zZXJpZmA7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gJyMwZjAnO1xuXHRcdFx0Y3R4LnRleHRBbGlnbiA9ICdyaWdodCc7XG5cdFx0XHRjdHguZmlsbFRleHQoIE1hdGgucm91bmQoIHRoaXMuX2ZwcyApLCBjYW52YXMud2lkdGggLSBzaXplLCBzaXplICogMiApO1xuXHRcdH1cblxuXHRcdC8vIGNhbGwgY2FsbGJhY2sgZnVuY3Rpb24sIGlmIGRlZmluZWRcblx0XHRpZiAoIHRoaXMub25DYW52YXNEcmF3ICkge1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLl9jYW52YXNHcmFkaWVudDtcblx0XHRcdHRoaXMub25DYW52YXNEcmF3KCB0aGlzICk7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblxuXHRcdC8vIHNjaGVkdWxlIG5leHQgY2FudmFzIHVwZGF0ZVxuXHRcdHRoaXMuX3J1bklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCB0aW1lc3RhbXAgPT4gdGhpcy5fZHJhdyggdGltZXN0YW1wICkgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIEZGVCBkYXRhIGJpbiAoYXJyYXkgaW5kZXgpIHdoaWNoIHJlcHJlc2VudHMgYSBnaXZlbiBmcmVxdWVuY3lcblx0ICovXG5cdF9mcmVxVG9CaW4oIGZyZXEsIHJvdW5kaW5nID0gJ3JvdW5kJyApIHtcblx0XHRjb25zdCBtYXggPSB0aGlzLl9hbmFseXplclswXS5mcmVxdWVuY3lCaW5Db3VudCAtIDEsXG5cdFx0XHQgIGJpbiA9IE1hdGhbIHJvdW5kaW5nIF0oIGZyZXEgKiB0aGlzLmZmdFNpemUgLyB0aGlzLmF1ZGlvQ3R4LnNhbXBsZVJhdGUgKTtcblxuXHRcdHJldHVybiBiaW4gPCBtYXggPyBiaW4gOiBtYXg7XG5cdH1cblxuXHQvKipcblx0ICogR2VuZXJhdGUgY3VycmVudGx5IHNlbGVjdGVkIGdyYWRpZW50XG5cdCAqL1xuXHRfbWFrZUdyYWQoKSB7XG5cblx0XHRpZiAoICEgdGhpcy5fcmVhZHkgKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0Y29uc3QgY3R4ICAgICAgICAgICAgPSB0aGlzLl9jYW52YXNDdHgsXG5cdFx0XHQgIGNhbnZhcyAgICAgICAgID0gY3R4LmNhbnZhcyxcblx0XHRcdCAgaXNMdW1pQmFycyAgICAgPSB0aGlzLl9pc0x1bWlCYXJzLFxuXHRcdFx0ICBncmFkaWVudEhlaWdodCA9IGlzTHVtaUJhcnMgPyBjYW52YXMuaGVpZ2h0IDogY2FudmFzLmhlaWdodCAqICggMSAtIHRoaXMuX3JlZmxleFJhdGlvICogISB0aGlzLl9zdGVyZW8gKSB8IDAsXG5cdFx0XHQgIFx0XHRcdFx0XHQvLyBmb3Igc3RlcmVvIHdlIGtlZXAgdGhlIGZ1bGwgY2FudmFzIGhlaWdodCBhbmQgaGFuZGxlIHRoZSByZWZsZXggYXJlYXMgd2hpbGUgZ2VuZXJhdGluZyB0aGUgY29sb3Igc3RvcHNcblx0XHRcdCAgYW5hbHl6ZXJSYXRpbyAgPSAxIC0gdGhpcy5fcmVmbGV4UmF0aW8sXG5cdFx0XHQgIGluaXRpYWxYICAgICAgID0gdGhpcy5faW5pdGlhbFg7XG5cblx0XHQvLyBmb3IgcmFkaWFsIG1vZGVcblx0XHRjb25zdCBjZW50ZXJYICAgPSBjYW52YXMud2lkdGggPj4gMSxcblx0XHRcdCAgY2VudGVyWSAgID0gY2FudmFzLmhlaWdodCA+PiAxLFxuXHRcdFx0ICBtYXhSYWRpdXMgPSBNYXRoLm1pbiggY2VudGVyWCwgY2VudGVyWSApLFxuXHRcdFx0ICByYWRpdXMgICAgPSB0aGlzLl9yYWRpdXM7XG5cblx0XHRjb25zdCBjdXJyR3JhZGllbnQgPSB0aGlzLl9ncmFkaWVudHNbIHRoaXMuX2dyYWRpZW50IF0sXG5cdFx0XHQgIGNvbG9yU3RvcHMgICA9IGN1cnJHcmFkaWVudC5jb2xvclN0b3BzLFxuXHRcdFx0ICBpc0hvcml6b250YWwgPSBjdXJyR3JhZGllbnQuZGlyID09ICdoJztcblxuXHRcdGxldCBncmFkO1xuXG5cdFx0aWYgKCB0aGlzLl9yYWRpYWwgKVxuXHRcdFx0Z3JhZCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCggY2VudGVyWCwgY2VudGVyWSwgbWF4UmFkaXVzLCBjZW50ZXJYLCBjZW50ZXJZLCByYWRpdXMgLSAoIG1heFJhZGl1cyAtIHJhZGl1cyApICogdGhpcy5fc3RlcmVvICk7XG5cdFx0ZWxzZVxuXHRcdFx0Z3JhZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCggLi4uKCBpc0hvcml6b250YWwgPyBbIGluaXRpYWxYLCAwLCBpbml0aWFsWCArIHRoaXMuX2FuYWx5emVyV2lkdGgsIDAgXSA6IFsgMCwgMCwgMCwgZ3JhZGllbnRIZWlnaHQgXSApICk7XG5cblx0XHRpZiAoIGNvbG9yU3RvcHMgKSB7XG5cdFx0XHRjb25zdCBkdWFsID0gdGhpcy5fc3RlcmVvICYmICEgdGhpcy5fc3BsaXRHcmFkaWVudCAmJiAhIGlzSG9yaXpvbnRhbDtcblxuXHRcdFx0Ly8gaGVscGVyIGZ1bmN0aW9uXG5cdFx0XHRjb25zdCBhZGRDb2xvclN0b3AgPSAoIG9mZnNldCwgY29sb3JJbmZvICkgPT4gZ3JhZC5hZGRDb2xvclN0b3AoIG9mZnNldCwgY29sb3JJbmZvLmNvbG9yIHx8IGNvbG9ySW5mbyApO1xuXG5cdFx0XHRmb3IgKCBsZXQgY2hhbm5lbCA9IDA7IGNoYW5uZWwgPCAxICsgZHVhbDsgY2hhbm5lbCsrICkge1xuXHRcdFx0XHRjb2xvclN0b3BzLmZvckVhY2goICggY29sb3JJbmZvLCBpbmRleCApID0+IHtcblxuXHRcdFx0XHRcdGNvbnN0IG1heEluZGV4ID0gY29sb3JTdG9wcy5sZW5ndGggLSAxO1xuXG5cdFx0XHRcdFx0bGV0IG9mZnNldCA9IGNvbG9ySW5mby5wb3MgIT09IHVuZGVmaW5lZCA/IGNvbG9ySW5mby5wb3MgOiBpbmRleCAvIG1heEluZGV4O1xuXG5cdFx0XHRcdFx0Ly8gaW4gZHVhbCBtb2RlIChub3Qgc3BsaXQpLCB1c2UgaGFsZiB0aGUgb3JpZ2luYWwgb2Zmc2V0IGZvciBlYWNoIGNoYW5uZWxcblx0XHRcdFx0XHRpZiAoIGR1YWwgKVxuXHRcdFx0XHRcdFx0b2Zmc2V0IC89IDI7XG5cblx0XHRcdFx0XHQvLyBjb25zdHJhaW4gdGhlIG9mZnNldCB3aXRoaW4gdGhlIHVzZWZ1bCBhbmFseXplciBhcmVhcyAoYXZvaWQgcmVmbGV4IGFyZWFzKVxuXHRcdFx0XHRcdGlmICggdGhpcy5fc3RlcmVvICYmICEgaXNMdW1pQmFycyAmJiAhIHRoaXMuX3JhZGlhbCAmJiAhIGlzSG9yaXpvbnRhbCApIHtcblx0XHRcdFx0XHRcdG9mZnNldCAqPSBhbmFseXplclJhdGlvO1xuXHRcdFx0XHRcdFx0Ly8gc2tpcCB0aGUgZmlyc3QgcmVmbGV4IGFyZWEgaW4gc3BsaXQgbW9kZVxuXHRcdFx0XHRcdFx0aWYgKCAhIGR1YWwgJiYgb2Zmc2V0ID4gLjUgKiBhbmFseXplclJhdGlvIClcblx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IC41ICogdGhpcy5fcmVmbGV4UmF0aW87XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gb25seSBmb3Igc3BsaXQgbW9kZVxuXHRcdFx0XHRcdGlmICggY2hhbm5lbCA9PSAxICkge1xuXHRcdFx0XHRcdFx0Ly8gYWRkIGNvbG9ycyBpbiByZXZlcnNlIG9yZGVyIGlmIHJhZGlhbCBvciBsdW1pIGFyZSBhY3RpdmVcblx0XHRcdFx0XHRcdGlmICggdGhpcy5fcmFkaWFsIHx8IGlzTHVtaUJhcnMgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHJldkluZGV4ID0gbWF4SW5kZXggLSBpbmRleDtcblx0XHRcdFx0XHRcdFx0Y29sb3JJbmZvID0gY29sb3JTdG9wc1sgcmV2SW5kZXggXTtcblx0XHRcdFx0XHRcdFx0b2Zmc2V0ID0gMSAtICggY29sb3JJbmZvLnBvcyAhPT0gdW5kZWZpbmVkID8gY29sb3JJbmZvLnBvcyA6IHJldkluZGV4IC8gbWF4SW5kZXggKSAvIDI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlIGZpcnN0IG9mZnNldCBpcyBub3QgMCwgY3JlYXRlIGFuIGFkZGl0aW9uYWwgY29sb3Igc3RvcCB0byBwcmV2ZW50IGJsZWVkaW5nIGZyb20gdGhlIGZpcnN0IGNoYW5uZWxcblx0XHRcdFx0XHRcdFx0aWYgKCBpbmRleCA9PSAwICYmIG9mZnNldCA+IDAgKVxuXHRcdFx0XHRcdFx0XHRcdGFkZENvbG9yU3RvcCggLjUsIGNvbG9ySW5mbyApO1xuXHRcdFx0XHRcdFx0XHQvLyBidW1wIHRoZSBvZmZzZXQgdG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSBncmFkaWVudFxuXHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gLjU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gYWRkIGdyYWRpZW50IGNvbG9yIHN0b3Bcblx0XHRcdFx0XHRhZGRDb2xvclN0b3AoIG9mZnNldCwgY29sb3JJbmZvICk7XG5cblx0XHRcdFx0XHQvLyBjcmVhdGUgYWRkaXRpb25hbCBjb2xvciBzdG9wIGF0IHRoZSBlbmQgb2YgZmlyc3QgY2hhbm5lbCB0byBwcmV2ZW50IGJsZWVkaW5nXG5cdFx0XHRcdFx0aWYgKCB0aGlzLl9zdGVyZW8gJiYgaW5kZXggPT0gbWF4SW5kZXggJiYgb2Zmc2V0IDwgLjUgKVxuXHRcdFx0XHRcdFx0YWRkQ29sb3JTdG9wKCAuNSwgY29sb3JJbmZvICk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMuX2NhbnZhc0dyYWRpZW50ID0gZ3JhZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBjaGFuZ2UgY2FudmFzIGRpbWVuc2lvbnMgb24gZGVtYW5kXG5cdCAqL1xuXHRfc2V0Q2FudmFzKCByZWFzb24gKSB7XG5cdFx0Ly8gaWYgaW5pdGlhbGl6YXRpb24gaXMgbm90IGZpbmlzaGVkLCBxdWl0XG5cdFx0aWYgKCAhIHRoaXMuX3JlYWR5IClcblx0XHRcdHJldHVybjtcblxuXHRcdGNvbnN0IGN0eCAgICAgICAgPSB0aGlzLl9jYW52YXNDdHgsXG5cdFx0XHQgIGNhbnZhcyAgICAgPSBjdHguY2FudmFzLFxuXHRcdFx0ICBjYW52YXNYICAgID0gdGhpcy5fc2NhbGVYLmNhbnZhcyxcblx0XHRcdCAgcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIC8gKCB0aGlzLl9sb1JlcyArIDEgKTtcblxuXHRcdGxldCBzY3JlZW5XaWR0aCAgPSB3aW5kb3cuc2NyZWVuLndpZHRoICAqIHBpeGVsUmF0aW8sXG5cdFx0XHRzY3JlZW5IZWlnaHQgPSB3aW5kb3cuc2NyZWVuLmhlaWdodCAqIHBpeGVsUmF0aW87XG5cblx0XHQvLyBGaXggZm9yIGlPUyBTYWZhcmkgLSBzd2FwIHdpZHRoIGFuZCBoZWlnaHQgd2hlbiBpbiBsYW5kc2NhcGVcblx0XHRpZiAoIE1hdGguYWJzKCB3aW5kb3cub3JpZW50YXRpb24gKSA9PSA5MCAmJiBzY3JlZW5XaWR0aCA8IHNjcmVlbkhlaWdodCApXG5cdFx0XHRbIHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQgXSA9IFsgc2NyZWVuSGVpZ2h0LCBzY3JlZW5XaWR0aCBdO1xuXG5cdFx0Y29uc3QgaXNGdWxsc2NyZWVuID0gdGhpcy5pc0Z1bGxzY3JlZW4sXG5cdFx0XHQgIGlzQ2FudmFzRnMgICA9IGlzRnVsbHNjcmVlbiAmJiB0aGlzLl9mc0VsID09IGNhbnZhcyxcblx0XHRcdCAgbmV3V2lkdGggICAgID0gaXNDYW52YXNGcyA/IHNjcmVlbldpZHRoICA6ICggdGhpcy5fd2lkdGggIHx8IHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCAgfHwgdGhpcy5fZGVmYXVsdFdpZHRoICApICogcGl4ZWxSYXRpbyB8IDAsXG5cdFx0XHQgIG5ld0hlaWdodCAgICA9IGlzQ2FudmFzRnMgPyBzY3JlZW5IZWlnaHQgOiAoIHRoaXMuX2hlaWdodCB8fCB0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0IHx8IHRoaXMuX2RlZmF1bHRIZWlnaHQgKSAqIHBpeGVsUmF0aW8gfCAwO1xuXG5cdFx0Ly8gc2V0L3VwZGF0ZSBvYmplY3QgcHJvcGVydGllc1xuXHRcdHRoaXMuX3BpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuXHRcdHRoaXMuX2ZzV2lkdGggICAgPSBzY3JlZW5XaWR0aDtcblx0XHR0aGlzLl9mc0hlaWdodCAgID0gc2NyZWVuSGVpZ2h0O1xuXG5cdFx0Ly8gaWYgY2FudmFzIGRpbWVuc2lvbnMgaGF2ZW4ndCBjaGFuZ2VkLCBxdWl0XG5cdFx0aWYgKCBjYW52YXMud2lkdGggPT0gbmV3V2lkdGggJiYgY2FudmFzLmhlaWdodCA9PSBuZXdIZWlnaHQgKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0Ly8gYXBwbHkgbmV3IGRpbWVuc2lvbnNcblx0XHRjYW52YXMud2lkdGggID0gbmV3V2lkdGg7XG5cdFx0Y2FudmFzLmhlaWdodCA9IG5ld0hlaWdodDtcblxuXHRcdC8vIHVwZGF0ZSBpbnRlcm5hbCB2YXJpYWJsZXNcblx0XHR0aGlzLl9jYWxjQXV4KCk7XG5cblx0XHQvLyBpZiBub3QgaW4gb3ZlcmxheSBtb2RlLCBwYWludCB0aGUgY2FudmFzIGJsYWNrXG5cdFx0aWYgKCAhIHRoaXMub3ZlcmxheSApIHtcblx0XHRcdGN0eC5maWxsU3R5bGUgPSAnIzAwMCc7XG5cdFx0XHRjdHguZmlsbFJlY3QoIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQgKTtcblx0XHR9XG5cblx0XHQvLyBzZXQgbGluZUpvaW4gcHJvcGVydHkgZm9yIGFyZWEgZmlsbCBtb2RlICh0aGlzIGlzIHJlc2V0IHdoZW5ldmVyIHRoZSBjYW52YXMgc2l6ZSBjaGFuZ2VzKVxuXHRcdGN0eC5saW5lSm9pbiA9ICdiZXZlbCc7XG5cblx0XHQvLyB1cGRhdGUgZGltZW5zaW9ucyBvZiB0aGUgc2NhbGUgY2FudmFzXG5cdFx0Y2FudmFzWC53aWR0aCA9IG5ld1dpZHRoO1xuXHRcdGNhbnZhc1guaGVpZ2h0ID0gTWF0aC5tYXgoIDIwICogcGl4ZWxSYXRpbywgTWF0aC5taW4oIG5ld1dpZHRoLCBuZXdIZWlnaHQgKSAvIDI3IHwgMCApO1xuXG5cdFx0Ly8gKHJlKWdlbmVyYXRlIGdyYWRpZW50XG5cdFx0dGhpcy5fbWFrZUdyYWQoKTtcblxuXHRcdC8vIGNhbGN1bGF0ZSBiYXIgcG9zaXRpb25zIGFuZCBsZWQgb3B0aW9uc1xuXHRcdHRoaXMuX2NhbGNCYXJzKCk7XG5cblx0XHQvLyBkZXRlY3QgZnVsbHNjcmVlbiBjaGFuZ2VzIChmb3IgU2FmYXJpKVxuXHRcdGlmICggdGhpcy5fZnNTdGF0dXMgIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9mc1N0YXR1cyAhPT0gaXNGdWxsc2NyZWVuIClcblx0XHRcdHJlYXNvbiA9ICdmc2NoYW5nZSc7XG5cdFx0dGhpcy5fZnNTdGF0dXMgPSBpc0Z1bGxzY3JlZW47XG5cblx0XHQvLyBjYWxsIHRoZSBjYWxsYmFjayBmdW5jdGlvbiwgaWYgZGVmaW5lZFxuXHRcdGlmICggdGhpcy5vbkNhbnZhc1Jlc2l6ZSApXG5cdFx0XHR0aGlzLm9uQ2FudmFzUmVzaXplKCByZWFzb24sIHRoaXMgKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgb2JqZWN0IHByb3BlcnRpZXNcblx0ICovXG5cdF9zZXRQcm9wcyggb3B0aW9ucywgdXNlRGVmYXVsdHMgKSB7XG5cblx0XHQvLyBzZXR0aW5ncyBkZWZhdWx0c1xuXHRcdGNvbnN0IGRlZmF1bHRzID0ge1xuXHRcdFx0YWxwaGFCYXJzICAgIDogZmFsc2UsXG5cdFx0XHRiYXJTcGFjZSAgICAgOiAwLjEsXG5cdFx0XHRiZ0FscGhhICAgICAgOiAwLjcsXG5cdFx0XHRmZnRTaXplICAgICAgOiA4MTkyLFxuXHRcdFx0ZmlsbEFscGhhICAgIDogMSxcblx0XHRcdGdyYWRpZW50ICAgICA6ICdjbGFzc2ljJyxcblx0XHRcdGxlZEJhcnMgICAgICA6IGZhbHNlLFxuXHRcdFx0bGluZVdpZHRoICAgIDogMCxcblx0XHRcdGxvUmVzICAgICAgICA6IGZhbHNlLFxuXHRcdFx0bHVtaUJhcnMgICAgIDogZmFsc2UsXG5cdFx0XHRtYXhEZWNpYmVscyAgOiAtMjUsXG5cdFx0XHRtYXhGcmVxICAgICAgOiAyMjAwMCxcblx0XHRcdG1pbkRlY2liZWxzICA6IC04NSxcblx0XHRcdG1pbkZyZXEgICAgICA6IDIwLFxuXHRcdFx0bWlycm9yICAgICAgIDogMCxcblx0XHRcdG1vZGUgICAgICAgICA6IDAsXG5cdFx0XHRvdXRsaW5lQmFycyAgOiBmYWxzZSxcblx0XHRcdG92ZXJsYXkgICAgICA6IGZhbHNlLFxuXHRcdFx0cmFkaWFsXHRcdCA6IGZhbHNlLFxuXHRcdFx0cmVmbGV4QWxwaGEgIDogMC4xNSxcblx0XHRcdHJlZmxleEJyaWdodCA6IDEsXG5cdFx0XHRyZWZsZXhGaXQgICAgOiB0cnVlLFxuXHRcdFx0cmVmbGV4UmF0aW8gIDogMCxcblx0XHRcdHNob3dCZ0NvbG9yICA6IHRydWUsXG5cdFx0XHRzaG93RlBTICAgICAgOiBmYWxzZSxcblx0XHRcdHNob3dQZWFrcyAgICA6IHRydWUsXG5cdFx0XHRzaG93U2NhbGVYICAgOiB0cnVlLFxuXHRcdFx0c2hvd1NjYWxlWSAgIDogZmFsc2UsXG5cdFx0XHRzbW9vdGhpbmcgICAgOiAwLjUsXG5cdFx0XHRzcGluU3BlZWQgICAgOiAwLFxuXHRcdFx0c3BsaXRHcmFkaWVudDogZmFsc2UsXG5cdFx0XHRzdGFydCAgICAgICAgOiB0cnVlLFxuXHRcdFx0c3RlcmVvICAgICAgIDogZmFsc2UsXG5cdFx0XHR1c2VDYW52YXMgICAgOiB0cnVlLFxuXHRcdFx0dm9sdW1lICAgICAgIDogMSxcblx0XHR9O1xuXG5cdFx0Ly8gY2FsbGJhY2sgZnVuY3Rpb25zIHByb3BlcnRpZXNcblx0XHRjb25zdCBjYWxsYmFja3MgPSBbICdvbkNhbnZhc0RyYXcnLCAnb25DYW52YXNSZXNpemUnIF07XG5cblx0XHQvLyBidWlsZCBhbiBhcnJheSBvZiB2YWxpZCBwcm9wZXJ0aWVzOyBgc3RhcnRgIGlzIG5vdCBhbiBhY3R1YWwgcHJvcGVydHkgYW5kIGlzIGhhbmRsZWQgYWZ0ZXIgc2V0dGluZyBldmVyeXRoaW5nIGVsc2Vcblx0XHRjb25zdCB2YWxpZFByb3BzID0gT2JqZWN0LmtleXMoIGRlZmF1bHRzICkuZmlsdGVyKCBlID0+IGUgIT0gJ3N0YXJ0JyApLmNvbmNhdCggY2FsbGJhY2tzLCBbJ2hlaWdodCcsICd3aWR0aCddICk7XG5cblx0XHQvLyBoYW5kbGUgZGVwcmVjYXRlZCBgc2hvd0xlZHNgIHByb3BlcnR5XG5cdFx0aWYgKCBvcHRpb25zICYmIG9wdGlvbnMuc2hvd0xlZHMgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmxlZEJhcnMgPT09IHVuZGVmaW5lZCApXG5cdFx0XHRvcHRpb25zLmxlZEJhcnMgPSBvcHRpb25zLnNob3dMZWRzO1xuXG5cdFx0aWYgKCB1c2VEZWZhdWx0cyB8fCBvcHRpb25zID09PSB1bmRlZmluZWQgKVxuXHRcdFx0b3B0aW9ucyA9IHsgLi4uZGVmYXVsdHMsIC4uLm9wdGlvbnMgfTsgLy8gbWVyZ2Ugb3B0aW9ucyB3aXRoIGRlZmF1bHRzXG5cblx0XHRmb3IgKCBjb25zdCBwcm9wIG9mIE9iamVjdC5rZXlzKCBvcHRpb25zICkgKSB7XG5cdFx0XHRpZiAoIGNhbGxiYWNrcy5pbmNsdWRlcyggcHJvcCApICYmIHR5cGVvZiBvcHRpb25zWyBwcm9wIF0gIT09ICdmdW5jdGlvbicgKSAvLyBjaGVjayBpbnZhbGlkIGNhbGxiYWNrXG5cdFx0XHRcdHRoaXNbIHByb3AgXSA9IHVuZGVmaW5lZDtcblx0XHRcdGVsc2UgaWYgKCB2YWxpZFByb3BzLmluY2x1ZGVzKCBwcm9wICkgKSAvLyBzZXQgb25seSB2YWxpZCBwcm9wZXJ0aWVzXG5cdFx0XHRcdHRoaXNbIHByb3AgXSA9IG9wdGlvbnNbIHByb3AgXTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdGlvbnMuc3RhcnQgIT09IHVuZGVmaW5lZCApXG5cdFx0XHR0aGlzLnRvZ2dsZUFuYWx5emVyKCBvcHRpb25zLnN0YXJ0ICk7XG5cdH1cblxufVxuXG4vKiBDdXN0b20gZXJyb3IgY2xhc3MgKi9cblxuY2xhc3MgQXVkaW9Nb3Rpb25FcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IoIGNvZGUsIG1lc3NhZ2UgKSB7XG5cdFx0c3VwZXIoIG1lc3NhZ2UgKTtcblx0XHR0aGlzLm5hbWUgPSAnQXVkaW9Nb3Rpb25FcnJvcic7XG5cdFx0dGhpcy5jb2RlID0gY29kZTtcblx0fVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/audiomotion-analyzer/src/audioMotion-analyzer.js\n");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_piano_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles/piano.css */ \"./src/styles/piano.css\");\n/* harmony import */ var _scripts_keyboard_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scripts/keyboard.js */ \"./src/scripts/keyboard.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7O0FBQTRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhcmsvLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4vc3R5bGVzL3BpYW5vLmNzcyc7XG5pbXBvcnQgJy4vc2NyaXB0cy9rZXlib2FyZC5qcyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ }),

/***/ "./src/scripts/keyboard.js":
/*!*********************************!*\
  !*** ./src/scripts/keyboard.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var audiomotion_analyzer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! audiomotion-analyzer */ \"./node_modules/audiomotion-analyzer/src/audioMotion-analyzer.js\");\n\ndocument.addEventListener('DOMContentLoaded', function (event) {\n  // REMOVE CONSOLE LOGS \n  // console.log = function() {};\n  //Web Audio API\n  let audioContext = new (window.AudioContext || window.webkitAudioContext)(); //base Audio context\n  let noteGain = audioContext.createGain(); //gain\n  let oscList = []; //store key pressed oscilliators\n  let filter = audioContext.createBiquadFilter();\n  let noteFreq = {\n    //octave-1\n    '90': 261.626,\n    //Z, C4\n    '83': 277.183,\n    //S, C4#\n    '88': 293.665,\n    //X, D4\n    '68': 311.127,\n    //D, D4#\n    '67': 329.628,\n    //C, E4\n    '86': 349.228,\n    //V, F4\n    '71': 369.994,\n    //G, F4#\n    '66': 391.995,\n    //B, G4\n    '72': 415.305,\n    //H, G4#\n    '78': 440.000,\n    //N, A4\n    '74': 466.164,\n    //J, A4#\n    '77': 493.883,\n    //M, B4\n    '81': 523.251,\n    //Q, C5\n    '50': 554.365,\n    //2, C5#\n    '87': 587.329,\n    //W, D5\n    '51': 622.254,\n    //3, D5\n    '69': 659.255,\n    //E, E5\n    '82': 698.456,\n    //R, F5\n    '53': 739.989,\n    //5, F5#\n    '84': 783.991,\n    //T, G5\n    '54': 830.609,\n    //6, G5#\n    '89': 880.000,\n    //Y, A5\n    '55': 932.328,\n    //7, A5#\n    '85': 987.767,\n    //U, B5\n    '73': 1046.50 //I, C6\n  }; //key codes & note frequencies\n  let volumeControl = document.querySelector(\"input[name='volume']\");\n  let attackTime = 0.3;\n  let volume = 0;\n  let sustainLevel = 0.8;\n  let releaseTime = 0.3;\n\n  //DOM \n\n  let waveForm = document.querySelector(\"select[name='waveform']\");\n  let kick = document.getElementsByClassName('kick');\n  let hihat = document.getElementsByClassName('hihat');\n  let bass = document.getElementsByClassName('bass');\n  let choir = document.getElementsByClassName('choir');\n  let bell = document.getElementsByClassName('bell');\n  let vocal = document.getElementsByClassName('vocal');\n  let power = document.getElementById(\"power\");\n  let pads = [];\n  pads.push(kick, hihat, bass, choir, bell, vocal, power);\n  let hihat_audio = hihat[0].children[0];\n  let kick_audio = kick[0].children[0];\n  let bass_audio = bass[0].children[0];\n  let choir_audio = choir[0].children[0];\n  let bell_audio = bell[0].children[0];\n  let vocal_audio = vocal[0].children[0];\n  let audios = [];\n  audios.push(hihat_audio, kick_audio, bass_audio, choir_audio, bell_audio, vocal_audio);\n  let instructions_label = document.getElementById('instructions-label');\n  let instructions_modal = document.getElementById('instructions-modal');\n  let envelope_checkbox = document.getElementById('envelope-checkbox');\n  const attackControl = document.querySelector('#attack-control');\n  const releaseControl = document.querySelector('#release-control');\n\n  //************* EVENT LISTENERS ****************\n  window.addEventListener('keydown', keyDown);\n  window.addEventListener('keyup', keyUp);\n  volumeControl.addEventListener('change', adjustVolume, false);\n  waveForm.addEventListener('change', function (event) {\n    waveForm = event.target.value;\n  });\n  instructions_label.addEventListener('click', function (e) {\n    instructions_modal.style.display = \"block\";\n    // console.log(instructions_label);\n    // console.log(instructions_modal);\n  });\n  window.addEventListener(\"load\", function (e) {\n    instructions_modal.style.display = \"block\";\n  });\n  window.onclick = function (event) {\n    if (event.target === instructions_modal) {\n      // console.log(event);\n      instructions_modal.style.display = \"none\";\n    }\n  };\n  hihat[0].addEventListener('click', function (e) {\n    e.preventDefault();\n    if (hihat_audio.paused) {\n      hihat_audio.play();\n      hihat[0].style.color = 'red';\n    } else {\n      hihat_audio.pause();\n      hihat[0].style.color = 'black';\n    }\n    audioMotion.connectInput(hihat_audio);\n  });\n  kick[0].addEventListener('click', function (e) {\n    e.preventDefault();\n    if (kick_audio.paused) {\n      kick_audio.play();\n      kick[0].style.color = 'red';\n    } else {\n      kick_audio.pause();\n      kick[0].style.color = 'black';\n    }\n    audioMotion.connectInput(kick_audio);\n  });\n  bass[0].addEventListener('click', function (e) {\n    e.preventDefault();\n    if (bass_audio.paused) {\n      bass_audio.play();\n      bass[0].style.color = 'red';\n    } else {\n      bass_audio.pause();\n      bass[0].style.color = 'black';\n    }\n    audioMotion.connectInput(bass_audio);\n  });\n  bell[0].addEventListener('click', function (e) {\n    e.preventDefault();\n    if (bell_audio.paused) {\n      bell_audio.play();\n      bell[0].style.color = 'blue';\n    } else {\n      bell_audio.pause();\n      bell[0].style.color = 'black';\n    }\n    audioMotion.connectInput(bell_audio);\n  });\n  choir[0].addEventListener('click', function (e) {\n    e.preventDefault();\n    if (choir_audio.paused) {\n      choir_audio.play();\n      choir[0].style.color = 'blue';\n    } else {\n      choir_audio.pause();\n      choir[0].style.color = 'black';\n    }\n    audioMotion.connectInput(choir_audio);\n  });\n  vocal[0].addEventListener('click', function (e) {\n    e.preventDefault();\n    if (vocal_audio.paused) {\n      vocal_audio.play();\n      vocal[0].style.color = 'blue';\n    } else {\n      vocal_audio.pause();\n      vocal[0].style.color = 'black';\n    }\n    audioMotion.connectInput(vocal_audio);\n  });\n  attackControl.addEventListener('input', function () {\n    attackTime = parseFloat(this.value);\n  });\n  releaseControl.addEventListener('input', function () {\n    releaseTime = parseFloat(this.value);\n  });\n\n  //****************** FUNCTIONS *************************\n\n  //DOM element by data-freq\n  function keyDown(e) {\n    const key = e.keyCode.toString(); //key code            \n    if (noteFreq[key] && !oscList[key]) {\n      playNote(key);\n      // console.log(key)\n      let freq = noteFreq[key].toString();\n      let ele = document.querySelectorAll(`[data-freq = '${freq}']`);\n      //white or black?\n      // console.log(ele);\n      if (ele[0].className === 'white key') {\n        ele[0].style.backgroundColor = 'whitesmoke';\n        ele[0].style.boxShadow = \"0 0 7px #fff, 0 0 10px #fff, 0 0 21px #fff, 0 0 42px rgb(218, 216, 99)\";\n      } else if (ele[0].className === 'black key') {\n        ele[0].style.backgroundColor = 'yellow';\n        ele[0].style.boxShadow = \"0 0 7px #fff, 0 0 10px #fff, 0 0 21px #fff, 0 0 42px rgb(218, 216, 99)\";\n      }\n    }\n  }\n  ;\n  function keyUp(e) {\n    const key = e.keyCode.toString(); //55\n    if (noteFreq[key] && oscList[key]) {\n      oscList[key].stop();\n      delete oscList[key];\n      // console.log(oscList);\n      let freq = noteFreq[key].toString();\n      let ele = document.querySelectorAll(`[data-freq = '${freq}']`);\n      //white or black?\n      if (ele[0].className === 'white key') {\n        ele[0].style.backgroundColor = 'grey';\n        ele[0].style.boxShadow = 'none';\n      } else if (ele[0].className === 'black key') {\n        ele[0].style.backgroundColor = '#3d004e';\n        ele[0].style.boxShadow = 'none';\n      }\n      ;\n    }\n  }\n  ;\n\n  // AUDIO VISUALIZER\n  const audioMotion = new audiomotion_analyzer__WEBPACK_IMPORTED_MODULE_0__[\"default\"](document.getElementById('container'), {\n    gradient: 'prism'\n    // radial: true,\n    // spinSpeed: 20,\n  });\n  function playNote(key) {\n    const audioCtx = audioMotion.audioCtx;\n    const osc = audioCtx.createOscillator();\n    noteGain = audioCtx.createGain();\n    noteGain.gain.setValueAtTime(0, 0);\n    noteGain.gain.linearRampToValueAtTime(sustainLevel, audioCtx.currentTime + attackTime);\n    // noteGain.gain.setValueAtTime(sustainLevel, audioCtx.currentTime + 1 - releaseTime);\n    noteGain.gain.setValueAtTime(0, audioCtx.currentTime + 1 - releaseTime);\n    noteGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 5);\n\n    // noteGain.gain.value = volumeControl.value\n    osc.frequency.setValueAtTime(noteFreq[key], audioCtx.currentTime);\n    osc.type = waveForm; //selected waveform\n    oscList[key] = osc; //261\n    oscList[key].connect(noteGain); //sound connected\n    audioMotion.connectInput(noteGain);\n    // noteGain.gain.value = volumeControl.value\n    oscList[key].start();\n  }\n  function adjustVolume(e) {\n    noteGain.gain.value = volumeControl.value;\n  }\n  ;\n  power.addEventListener('click', function () {\n    // play or pause track depending on state\n    if (this.dataset.playing === 'false') {\n      this.dataset.playing = 'true';\n    } else if (this.dataset.playing === 'true') {\n      audios.forEach(el => {\n        el.pause();\n      });\n      pads.forEach(pad => {\n        pad[0].style.color = \"black\";\n      });\n\n      // Kill pads\n      audioCtx.close();\n      //Kill piano\n\n      this.dataset.playing = 'false';\n    }\n  }, false);\n\n  //CONNECTIONS\n\n  noteGain.connect(filter);\n  filter.connect(audioContext.destination);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TyxDQUFDRSxHQUFHLElBQUk7UUFDaEJBLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQ3RDLEtBQUssQ0FBQ00sS0FBSyxHQUFHLE9BQU87TUFDaEMsQ0FBQyxDQUFDOztNQUVGO01BQ0FpQixRQUFRLENBQUNnQixLQUFLLENBQUMsQ0FBQztNQUNoQjs7TUFFQSxJQUFJLENBQUNMLE9BQU8sQ0FBQ0MsT0FBTyxHQUFHLE9BQU87SUFDbEM7RUFDSixDQUFDLEVBQUUsS0FBSyxDQUFDOztFQUVUOztFQUVBOUUsUUFBUSxDQUFDMkUsT0FBTyxDQUFDeEUsTUFBTSxDQUFDO0VBQ3hCQSxNQUFNLENBQUN3RSxPQUFPLENBQUMvRSxZQUFZLENBQUN1RixXQUFXLENBQUM7QUFFNUMsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhcmsvLi9zcmMvc2NyaXB0cy9rZXlib2FyZC5qcz8wZGZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBBdWRpb01vdGlvbkFuYWx5emVyIGZyb20gJ2F1ZGlvbW90aW9uLWFuYWx5emVyJztcblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAvLyBSRU1PVkUgQ09OU09MRSBMT0dTIFxuICAgICAgICAvLyBjb25zb2xlLmxvZyA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgIC8vV2ViIEF1ZGlvIEFQSVxuICAgICAgICBsZXQgYXVkaW9Db250ZXh0ID0gbmV3ICh3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpKCk7IC8vYmFzZSBBdWRpbyBjb250ZXh0XG4gICAgICAgIGxldCBub3RlR2FpbiA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7IC8vZ2FpblxuICAgICAgICBsZXQgb3NjTGlzdCA9IFtdOyAvL3N0b3JlIGtleSBwcmVzc2VkIG9zY2lsbGlhdG9yc1xuICAgICAgICBsZXQgZmlsdGVyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuICAgICAgICBsZXQgbm90ZUZyZXEgPSB7XG4gICAgICAgICAgICAvL29jdGF2ZS0xXG4gICAgICAgICAgICAnOTAnOiAyNjEuNjI2LCAvL1osIEM0XG4gICAgICAgICAgICAnODMnOiAyNzcuMTgzLCAvL1MsIEM0I1xuICAgICAgICAgICAgJzg4JzogMjkzLjY2NSwgLy9YLCBENFxuICAgICAgICAgICAgJzY4JzogMzExLjEyNywgLy9ELCBENCNcbiAgICAgICAgICAgICc2Nyc6IDMyOS42MjgsIC8vQywgRTRcbiAgICAgICAgICAgICc4Nic6IDM0OS4yMjgsIC8vViwgRjRcbiAgICAgICAgICAgICc3MSc6IDM2OS45OTQsIC8vRywgRjQjXG4gICAgICAgICAgICAnNjYnOiAzOTEuOTk1LCAvL0IsIEc0XG4gICAgICAgICAgICAnNzInOiA0MTUuMzA1LCAvL0gsIEc0I1xuICAgICAgICAgICAgJzc4JzogNDQwLjAwMCwgLy9OLCBBNFxuICAgICAgICAgICAgJzc0JzogNDY2LjE2NCwgLy9KLCBBNCNcbiAgICAgICAgICAgICc3Nyc6IDQ5My44ODMsIC8vTSwgQjRcbiAgICAgICAgICAgICc4MSc6IDUyMy4yNTEsIC8vUSwgQzVcbiAgICAgICAgICAgICc1MCc6IDU1NC4zNjUsIC8vMiwgQzUjXG4gICAgICAgICAgICAnODcnOiA1ODcuMzI5LCAvL1csIEQ1XG4gICAgICAgICAgICAnNTEnOiA2MjIuMjU0LCAvLzMsIEQ1XG4gICAgICAgICAgICAnNjknOiA2NTkuMjU1LCAvL0UsIEU1XG4gICAgICAgICAgICAnODInOiA2OTguNDU2LCAvL1IsIEY1XG4gICAgICAgICAgICAnNTMnOiA3MzkuOTg5LCAvLzUsIEY1I1xuICAgICAgICAgICAgJzg0JzogNzgzLjk5MSwgLy9ULCBHNVxuICAgICAgICAgICAgJzU0JzogODMwLjYwOSwgLy82LCBHNSNcbiAgICAgICAgICAgICc4OSc6IDg4MC4wMDAsIC8vWSwgQTVcbiAgICAgICAgICAgICc1NSc6IDkzMi4zMjgsIC8vNywgQTUjXG4gICAgICAgICAgICAnODUnOiA5ODcuNzY3LCAvL1UsIEI1XG4gICAgICAgICAgICAnNzMnOiAxMDQ2LjUwLCAvL0ksIEM2XG4gICAgXG4gICAgICAgIH0gLy9rZXkgY29kZXMgJiBub3RlIGZyZXF1ZW5jaWVzXG4gICAgICAgIGxldCB2b2x1bWVDb250cm9sID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImlucHV0W25hbWU9J3ZvbHVtZSddXCIpO1xuICAgICAgICBsZXQgYXR0YWNrVGltZSA9IDAuM1xuICAgICAgICBsZXQgdm9sdW1lID0gMDtcbiAgICAgICAgbGV0IHN1c3RhaW5MZXZlbCA9IDAuOFxuICAgICAgICBsZXQgcmVsZWFzZVRpbWUgPSAwLjNcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLy9ET00gXG4gICAgICAgIFxuICAgICAgICBsZXQgd2F2ZUZvcm0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwic2VsZWN0W25hbWU9J3dhdmVmb3JtJ11cIik7XG4gICAgICAgIGxldCBraWNrID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgna2ljaycpO1xuICAgICAgICBsZXQgaGloYXQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdoaWhhdCcpO1xuICAgICAgICBsZXQgYmFzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2Jhc3MnKTtcbiAgICAgICAgbGV0IGNob2lyID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2hvaXInKTtcbiAgICAgICAgbGV0IGJlbGwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdiZWxsJyk7XG4gICAgICAgIGxldCB2b2NhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3ZvY2FsJyk7XG4gICAgICAgIGxldCBwb3dlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicG93ZXJcIik7XG5cbiAgICAgICAgbGV0IHBhZHMgPSBbXVxuICAgICAgICBwYWRzLnB1c2goa2ljaywgaGloYXQsIGJhc3MsIGNob2lyLCBiZWxsLCB2b2NhbCwgcG93ZXIpO1xuXG4gICAgICAgIGxldCBoaWhhdF9hdWRpbyA9IGhpaGF0WzBdLmNoaWxkcmVuWzBdO1xuICAgICAgICBsZXQga2lja19hdWRpbyA9IGtpY2tbMF0uY2hpbGRyZW5bMF07ICBcbiAgICAgICAgbGV0IGJhc3NfYXVkaW8gPSBiYXNzWzBdLmNoaWxkcmVuWzBdO1xuICAgICAgICBsZXQgY2hvaXJfYXVkaW8gPSBjaG9pclswXS5jaGlsZHJlblswXTtcbiAgICAgICAgbGV0IGJlbGxfYXVkaW8gPSBiZWxsWzBdLmNoaWxkcmVuWzBdO1xuICAgICAgICBsZXQgdm9jYWxfYXVkaW8gPSB2b2NhbFswXS5jaGlsZHJlblswXTtcblxuICAgICAgICBsZXQgYXVkaW9zID0gW11cbiAgICAgICAgYXVkaW9zLnB1c2goaGloYXRfYXVkaW8sIGtpY2tfYXVkaW8sIGJhc3NfYXVkaW8sIGNob2lyX2F1ZGlvLCBiZWxsX2F1ZGlvLCB2b2NhbF9hdWRpbyk7XG5cbiAgICAgICAgbGV0IGluc3RydWN0aW9uc19sYWJlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbnN0cnVjdGlvbnMtbGFiZWwnKTtcbiAgICAgICAgbGV0IGluc3RydWN0aW9uc19tb2RhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbnN0cnVjdGlvbnMtbW9kYWwnKTtcbiAgICAgICAgbGV0IGVudmVsb3BlX2NoZWNrYm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VudmVsb3BlLWNoZWNrYm94Jyk7XG4gICAgICAgIGNvbnN0IGF0dGFja0NvbnRyb2wgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjYXR0YWNrLWNvbnRyb2wnKTtcbiAgICAgICAgY29uc3QgcmVsZWFzZUNvbnRyb2wgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcmVsZWFzZS1jb250cm9sJyk7XG4gICAgICAgIFxuICAgICAgICAvLyoqKioqKioqKioqKiogRVZFTlQgTElTVEVORVJTICoqKioqKioqKioqKioqKipcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlEb3duKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywga2V5VXApO1xuICAgICAgICB2b2x1bWVDb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGFkanVzdFZvbHVtZSwgZmFsc2UpO1xuXG4gICAgICAgIHdhdmVGb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB3YXZlRm9ybSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgfSk7ICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGluc3RydWN0aW9uc19sYWJlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zX21vZGFsLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhpbnN0cnVjdGlvbnNfbGFiZWwpO1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coaW5zdHJ1Y3Rpb25zX21vZGFsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNfbW9kYWwuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHdpbmRvdy5vbmNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBpbnN0cnVjdGlvbnNfbW9kYWwpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhldmVudCk7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zX21vZGFsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGhpaGF0WzBdLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoaGloYXRfYXVkaW8ucGF1c2VkKXtcbiAgICAgICAgICAgICAgICBoaWhhdF9hdWRpby5wbGF5KCk7XG4gICAgICAgICAgICAgICAgaGloYXRbMF0uc3R5bGUuY29sb3IgPSAncmVkJztcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIGhpaGF0X2F1ZGlvLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgaGloYXRbMF0uc3R5bGUuY29sb3IgPSAnYmxhY2snO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXVkaW9Nb3Rpb24uY29ubmVjdElucHV0KGhpaGF0X2F1ZGlvKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBraWNrWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChraWNrX2F1ZGlvLnBhdXNlZCkge1xuICAgICAgICAgICAgICAgIGtpY2tfYXVkaW8ucGxheSgpO1xuICAgICAgICAgICAgICAgIGtpY2tbMF0uc3R5bGUuY29sb3IgPSAncmVkJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAga2lja19hdWRpby5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIGtpY2tbMF0uc3R5bGUuY29sb3IgPSAnYmxhY2snO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXVkaW9Nb3Rpb24uY29ubmVjdElucHV0KGtpY2tfYXVkaW8pO1xuICAgICAgICB9KTtcblxuICAgICAgICBiYXNzWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChiYXNzX2F1ZGlvLnBhdXNlZCkge1xuICAgICAgICAgICAgICAgIGJhc3NfYXVkaW8ucGxheSgpO1xuICAgICAgICAgICAgICAgIGJhc3NbMF0uc3R5bGUuY29sb3IgPSAncmVkJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFzc19hdWRpby5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIGJhc3NbMF0uc3R5bGUuY29sb3IgPSAnYmxhY2snO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXVkaW9Nb3Rpb24uY29ubmVjdElucHV0KGJhc3NfYXVkaW8pO1xuICAgICAgICB9KTtcblxuICAgICAgICAgICBiZWxsWzBdLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChiZWxsX2F1ZGlvLnBhdXNlZCkge1xuICAgICAgICAgICAgICAgIGJlbGxfYXVkaW8ucGxheSgpO1xuICAgICAgICAgICAgICAgIGJlbGxbMF0uc3R5bGUuY29sb3IgPSAnYmx1ZSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJlbGxfYXVkaW8ucGF1c2UoKTtcbiAgICAgICAgICAgICAgICBiZWxsWzBdLnN0eWxlLmNvbG9yID0gJ2JsYWNrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1ZGlvTW90aW9uLmNvbm5lY3RJbnB1dChiZWxsX2F1ZGlvKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAgICAgY2hvaXJbMF0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGNob2lyX2F1ZGlvLnBhdXNlZCkge1xuICAgICAgICAgICAgICAgIGNob2lyX2F1ZGlvLnBsYXkoKTtcbiAgICAgICAgICAgICAgICBjaG9pclswXS5zdHlsZS5jb2xvciA9ICdibHVlJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hvaXJfYXVkaW8ucGF1c2UoKTtcbiAgICAgICAgICAgICAgICBjaG9pclswXS5zdHlsZS5jb2xvciA9ICdibGFjayc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdWRpb01vdGlvbi5jb25uZWN0SW5wdXQoY2hvaXJfYXVkaW8pO1xuICAgICAgICB9KTtcblxuICAgICAgICAgICB2b2NhbFswXS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAodm9jYWxfYXVkaW8ucGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgdm9jYWxfYXVkaW8ucGxheSgpO1xuICAgICAgICAgICAgICAgIHZvY2FsWzBdLnN0eWxlLmNvbG9yID0gJ2JsdWUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2b2NhbF9hdWRpby5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIHZvY2FsWzBdLnN0eWxlLmNvbG9yID0gJ2JsYWNrJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1ZGlvTW90aW9uLmNvbm5lY3RJbnB1dCh2b2NhbF9hdWRpbyk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgYXR0YWNrQ29udHJvbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBhdHRhY2tUaW1lID0gcGFyc2VGbG9hdCh0aGlzLnZhbHVlKVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJlbGVhc2VDb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJlbGVhc2VUaW1lID0gcGFyc2VGbG9hdCh0aGlzLnZhbHVlKVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vKioqKioqKioqKioqKioqKioqIEZVTkNUSU9OUyAqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIC8vRE9NIGVsZW1lbnQgYnkgZGF0YS1mcmVxXG4gICAgICAgIGZ1bmN0aW9uIGtleURvd24oZSkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gKGUua2V5Q29kZSkudG9TdHJpbmcoKTsgLy9rZXkgY29kZSAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKG5vdGVGcmVxW2tleV0gJiYgIW9zY0xpc3Rba2V5XSkge1xuICAgICAgICAgICAgICAgIHBsYXlOb3RlKGtleSk7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coa2V5KVxuICAgICAgICAgICAgICAgIGxldCBmcmVxID0gbm90ZUZyZXFba2V5XS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGxldCBlbGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS1mcmVxID0gJyR7ZnJlcX0nXWApO1xuICAgICAgICAgICAgICAgIC8vd2hpdGUgb3IgYmxhY2s/XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coZWxlKTtcbiAgICAgICAgICAgICAgICBpZihlbGVbMF0uY2xhc3NOYW1lID09PSAnd2hpdGUga2V5Jyl7XG4gICAgICAgICAgICAgICAgICAgIGVsZVswXS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnd2hpdGVzbW9rZSc7XG4gICAgICAgICAgICAgICAgICAgIGVsZVswXS5zdHlsZS5ib3hTaGFkb3cgPSBcIjAgMCA3cHggI2ZmZiwgMCAwIDEwcHggI2ZmZiwgMCAwIDIxcHggI2ZmZiwgMCAwIDQycHggcmdiKDIxOCwgMjE2LCA5OSlcIjtcbiAgICAgICAgICAgICAgICB9ZWxzZSBpZihlbGVbMF0uY2xhc3NOYW1lID09PSAnYmxhY2sga2V5Jyl7XG4gICAgICAgICAgICAgICAgICAgIGVsZVswXS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAneWVsbG93JztcbiAgICAgICAgICAgICAgICAgICAgZWxlWzBdLnN0eWxlLmJveFNoYWRvdyA9IFwiMCAwIDdweCAjZmZmLCAwIDAgMTBweCAjZmZmLCAwIDAgMjFweCAjZmZmLCAwIDAgNDJweCByZ2IoMjE4LCAyMTYsIDk5KVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIGtleVVwKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IChlLmtleUNvZGUpLnRvU3RyaW5nKCk7IC8vNTVcbiAgICAgICAgICAgIGlmIChub3RlRnJlcVtrZXldICYmIG9zY0xpc3Rba2V5XSkge1xuICAgICAgICAgICAgICAgIG9zY0xpc3Rba2V5XS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG9zY0xpc3Rba2V5XTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhvc2NMaXN0KTtcbiAgICAgICAgICAgICAgICBsZXQgZnJlcSA9IG5vdGVGcmVxW2tleV0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBsZXQgZWxlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChgW2RhdGEtZnJlcSA9ICcke2ZyZXF9J11gKTtcbiAgICAgICAgICAgICAgICAvL3doaXRlIG9yIGJsYWNrP1xuICAgICAgICAgICAgICAgIGlmIChlbGVbMF0uY2xhc3NOYW1lID09PSAnd2hpdGUga2V5Jykge1xuICAgICAgICAgICAgICAgICAgICBlbGVbMF0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ2dyZXknO1xuICAgICAgICAgICAgICAgICAgICBlbGVbMF0uc3R5bGUuYm94U2hhZG93ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlWzBdLmNsYXNzTmFtZSA9PT0gJ2JsYWNrIGtleScpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlWzBdLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjM2QwMDRlJztcbiAgICAgICAgICAgICAgICAgICAgZWxlWzBdLnN0eWxlLmJveFNoYWRvdyA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAgXG4gICAgICAgICAgICAvLyBBVURJTyBWSVNVQUxJWkVSXG4gICAgICAgIGNvbnN0IGF1ZGlvTW90aW9uID0gbmV3IEF1ZGlvTW90aW9uQW5hbHl6ZXIoIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWluZXInKSwge1xuICAgICAgICAgICAgZ3JhZGllbnQ6ICdwcmlzbSdcbiAgICAgICAgICAgIC8vIHJhZGlhbDogdHJ1ZSxcbiAgICAgICAgICAgIC8vIHNwaW5TcGVlZDogMjAsXG4gICAgICAgIH0gKVxuXG4gICAgICAgIGZ1bmN0aW9uIHBsYXlOb3RlKGtleSkge1xuICAgICAgICAgICAgY29uc3QgYXVkaW9DdHggPSBhdWRpb01vdGlvbi5hdWRpb0N0eDtcbiAgICAgICAgICAgIGNvbnN0IG9zYyA9IGF1ZGlvQ3R4LmNyZWF0ZU9zY2lsbGF0b3IoKTtcbiAgICAgICAgICAgIG5vdGVHYWluID0gYXVkaW9DdHguY3JlYXRlR2FpbigpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbm90ZUdhaW4uZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCAwKTtcbiAgICAgICAgICAgICAgICBub3RlR2Fpbi5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHN1c3RhaW5MZXZlbCwgYXVkaW9DdHguY3VycmVudFRpbWUgKyBhdHRhY2tUaW1lKTtcbiAgICAgICAgICAgICAgICAvLyBub3RlR2Fpbi5nYWluLnNldFZhbHVlQXRUaW1lKHN1c3RhaW5MZXZlbCwgYXVkaW9DdHguY3VycmVudFRpbWUgKyAxIC0gcmVsZWFzZVRpbWUpO1xuICAgICAgICAgICAgICAgIG5vdGVHYWluLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgYXVkaW9DdHguY3VycmVudFRpbWUgKyAxIC0gcmVsZWFzZVRpbWUpO1xuXG4gICAgICAgICAgICAgICAgbm90ZUdhaW4uZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCBhdWRpb0N0eC5jdXJyZW50VGltZSArIDUpO1xuXG4gICAgICAgICAgICAgICAgLy8gbm90ZUdhaW4uZ2Fpbi52YWx1ZSA9IHZvbHVtZUNvbnRyb2wudmFsdWVcbiAgICAgICAgICAgICAgICBvc2MuZnJlcXVlbmN5LnNldFZhbHVlQXRUaW1lKG5vdGVGcmVxW2tleV0sIGF1ZGlvQ3R4LmN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgICAgICBvc2MudHlwZSA9IHdhdmVGb3JtOyAvL3NlbGVjdGVkIHdhdmVmb3JtXG4gICAgICAgICAgICAgICAgb3NjTGlzdFtrZXldID0gb3NjOyAvLzI2MVxuICAgICAgICAgICAgICAgIG9zY0xpc3Rba2V5XS5jb25uZWN0KG5vdGVHYWluKTsgLy9zb3VuZCBjb25uZWN0ZWRcbiAgICAgICAgICAgICAgICBhdWRpb01vdGlvbi5jb25uZWN0SW5wdXQobm90ZUdhaW4pO1xuICAgICAgICAgICAgICAgIC8vIG5vdGVHYWluLmdhaW4udmFsdWUgPSB2b2x1bWVDb250cm9sLnZhbHVlXG4gICAgICAgICAgICAgICAgb3NjTGlzdFtrZXldLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIFxuXG4gICAgICAgIH1cbiAgICAgICAgIGZ1bmN0aW9uIGFkanVzdFZvbHVtZShlKSB7XG5cbiAgICAgICAgICAgIG5vdGVHYWluLmdhaW4udmFsdWUgPSB2b2x1bWVDb250cm9sLnZhbHVlXG4gICAgICAgICAgICBcbiAgICAgICAgfTtcbiAgICAgICAgcG93ZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHBsYXkgb3IgcGF1c2UgdHJhY2sgZGVwZW5kaW5nIG9uIHN0YXRlXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhc2V0LnBsYXlpbmcgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFzZXQucGxheWluZyA9ICd0cnVlJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhc2V0LnBsYXlpbmcgPT09ICd0cnVlJykge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGF1ZGlvcy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZWwucGF1c2UoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIHBhZHMuZm9yRWFjaChwYWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwYWRbMF0uc3R5bGUuY29sb3IgPSBcImJsYWNrXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEtpbGwgcGFkc1xuICAgICAgICAgICAgICAgIGF1ZGlvQ3R4LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgLy9LaWxsIHBpYW5vXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhc2V0LnBsYXlpbmcgPSAnZmFsc2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIC8vQ09OTkVDVElPTlNcbiAgICAgICAgXG4gICAgICAgIG5vdGVHYWluLmNvbm5lY3QoZmlsdGVyKTtcbiAgICAgICAgZmlsdGVyLmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcblxuICAgIH0pOyAgICBcbiAgICBcbiAgICAiXSwibmFtZXMiOlsiQXVkaW9Nb3Rpb25BbmFseXplciIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwiYXVkaW9Db250ZXh0Iiwid2luZG93IiwiQXVkaW9Db250ZXh0Iiwid2Via2l0QXVkaW9Db250ZXh0Iiwibm90ZUdhaW4iLCJjcmVhdGVHYWluIiwib3NjTGlzdCIsImZpbHRlciIsImNyZWF0ZUJpcXVhZEZpbHRlciIsIm5vdGVGcmVxIiwidm9sdW1lQ29udHJvbCIsInF1ZXJ5U2VsZWN0b3IiLCJhdHRhY2tUaW1lIiwidm9sdW1lIiwic3VzdGFpbkxldmVsIiwicmVsZWFzZVRpbWUiLCJ3YXZlRm9ybSIsImtpY2siLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwiaGloYXQiLCJiYXNzIiwiY2hvaXIiLCJiZWxsIiwidm9jYWwiLCJwb3dlciIsImdldEVsZW1lbnRCeUlkIiwicGFkcyIsInB1c2giLCJoaWhhdF9hdWRpbyIsImNoaWxkcmVuIiwia2lja19hdWRpbyIsImJhc3NfYXVkaW8iLCJjaG9pcl9hdWRpbyIsImJlbGxfYXVkaW8iLCJ2b2NhbF9hdWRpbyIsImF1ZGlvcyIsImluc3RydWN0aW9uc19sYWJlbCIsImluc3RydWN0aW9uc19tb2RhbCIsImVudmVsb3BlX2NoZWNrYm94IiwiYXR0YWNrQ29udHJvbCIsInJlbGVhc2VDb250cm9sIiwia2V5RG93biIsImtleVVwIiwiYWRqdXN0Vm9sdW1lIiwidGFyZ2V0IiwidmFsdWUiLCJlIiwic3R5bGUiLCJkaXNwbGF5Iiwib25jbGljayIsInByZXZlbnREZWZhdWx0IiwicGF1c2VkIiwicGxheSIsImNvbG9yIiwicGF1c2UiLCJhdWRpb01vdGlvbiIsImNvbm5lY3RJbnB1dCIsInBhcnNlRmxvYXQiLCJrZXkiLCJrZXlDb2RlIiwidG9TdHJpbmciLCJwbGF5Tm90ZSIsImZyZXEiLCJlbGUiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY2xhc3NOYW1lIiwiYmFja2dyb3VuZENvbG9yIiwiYm94U2hhZG93Iiwic3RvcCIsImdyYWRpZW50IiwiYXVkaW9DdHgiLCJvc2MiLCJjcmVhdGVPc2NpbGxhdG9yIiwiZ2FpbiIsInNldFZhbHVlQXRUaW1lIiwibGluZWFyUmFtcFRvVmFsdWVBdFRpbWUiLCJjdXJyZW50VGltZSIsImZyZXF1ZW5jeSIsInR5cGUiLCJjb25uZWN0Iiwic3RhcnQiLCJkYXRhc2V0IiwicGxheWluZyIsImZvckVhY2giLCJlbCIsInBhZCIsImNsb3NlIiwiZGVzdGluYXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/scripts/keyboard.js\n");

/***/ }),

/***/ "./src/index.scss":
/*!************************!*\
  !*** ./src/index.scss ***!
  \************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguc2NzcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFyay8uL3NyYy9pbmRleC5zY3NzPzk3NDUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/index.scss\n");

/***/ }),

/***/ "./src/styles/piano.css":
/*!******************************!*\
  !*** ./src/styles/piano.css ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGVzL3BpYW5vLmNzcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFyay8uL3NyYy9zdHlsZXMvcGlhbm8uY3NzPzlkYjMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/styles/piano.css\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	__webpack_require__("./src/index.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.scss");
/******/ 	
/******/ })()
;